---
title: Tools Related to Lifting
date: 2025-10-19
categories: [Compiler]
tags: [arm, compiler]     # TAG names should always be lowercase
published: false
---

> Problems: I want to find out tools about lifting binaries to assembly code, while preserving relocation and linking information.
> Problems continued from the last post, I want to convert an executable binary back to position-independent assembly code.

## Existing tools
- [Binary Ninja](https://cloud.binary.ninja/bn/cac518d6-6e84-4ae9-a338-a9ec0aacd074?view=Triage&func=66800&il=3&address=66800): which can be used online
  - which has a cfg view, we can get the basic blocks placement information from it.
    - In Binary Ninja, I noticed there actually has already a mapping from pc related address to the data itself.
    - ![binary ninja data mapping](/commons/images/compiler/binary_ninja.png)
  - Also, I noticed that the cfg (needed to place the basic blocks) is also generated by it.
    - ![binary ninja control flow graph](/commons/images/compiler/binary_ninja_cfg.png)
- [DDisasm](https://github.com/GrammaTech/ddisasm): a fast disassembler which is accurate enough for the resulting assembly code to be reassembled.
| Stack | Core idea | Typical output | Sweet spot |
| --- | --- | --- | --- |
| **DDisasm → GTIRB → gtirb-pprinter** | Disassemble to a **structured binary IR** (GTIRB) that preserves sections, blocks, edges, symbols, and then pretty-print **re-assemblable .s** | `.gtirb` (graph+metadata) → **assembly with labels per basic block** | When you want a **faithful, labeled assembly** you can tweak and (often) reassemble/relink; also nice for **programmatic block reordering** and regeneration |
| **angr + Ramblr** | **Lift** binary to VEX IR with powerful static/dynamic analyses (CFG, dataflow, symbolic exec); **Ramblr** reconstructs a **reassemblable** view for **patching/rebuilding** | Python objects (CFG, IR), patched **binary**, or assembly-like output for rewriting | When you need **analysis first** (CFG, slicing, constraint solving) and then **surgical patching** or a **reassembled** artifact to preserve semantics |

Functional differences (practical)
==================================

* **IR and ecosystem**
    
    * **GTIRB** is a **file/graph IR** for binaries (sections, byte intervals, code blocks, CFG, symbols). Great for **structural transforms** (e.g., reorder blocks, move data). It’s “printer-friendly.”
        
    * **angr** is an **analysis framework** (lifting to **VEX**, symbolic execution, dataflow). It excels at **discovering** things (CFG recovery quality, constant/alias resolution, indirect jumps) and **reasoning** about feasibility.
        
* **Re-assemblable output**
    
    * **GTIRB + pprinter**: generates **clean GAS** with **one label per basic block**, jump tables in `.rodata`, etc. Very convenient when your goal is **labeled .s** that you can feed to `as/ld`.
        
    * **Ramblr**: focuses on making a **reassembled/patchable** binary; it reconstructs relocations/symbols enough to produce an executable that preserves behavior. Output assembly is more “for rewriting” than for human editing, but it can be used that way.
  
# Usage of DDisasm

- Using docker
```shell
# Directly use the built docker
docker pull grammatech/ddisasm:latest
sudo docker images
REPOSITORY                                         TAG       IMAGE ID       CREATED        SIZE
grammatech/ddisasm                                 latest    0c4892488a8d   7 weeks ago    429MB
# run command and delete
sudo docker run --rm grammatech/ddisasm:latest ls /usr/local/bin
ddisasm
gtirb-layout
gtirb-pprinter
# check latest version
sudo docker run --rm grammatech/ddisasm:latest ddisasm --version
1.9.2 (1cd04b14 2025-08-26) ARM64+IA32+X64+ARM32+MIPS32
```
- disassembling the binary, generate the gtirb and asm file
```shell
sudo docker run --rm -v $PWD:/workspace -w /workspace grammatech/ddisasm:latest ddisasm Shootout-nestedloop --ir Shootout-nestedloop.gtirb
Building the initial gtirb representation [   4ms]
Processing module: Shootout-nestedloop
    disassembly              load [   5ms]    compute [  23ms]  transform WARNING: Could not find GLOBAL/WEAK symbol for _DYNAMIC
[   2ms]
    SCC analysis                              compute [   0ms]  transform [   0ms]
    no return analysis       load [   0ms]    compute [   0ms]  transform [   0ms]
    function inference       load [   0ms]    compute [   0ms]  transform [   0ms]
sudo docker run --rm -v $PWD:/workspace -w /workspace grammatech/ddisasm:latest ddisasm Shootout-nestedloop --asm Shootout-nestedloop-ddisasm.s
Building the initial gtirb representation [   4ms]
Processing module: Shootout-nestedloop
    disassembly              load [   5ms]    compute [  23ms]  transform WARNING: Could not find GLOBAL/WEAK symbol for _DYNAMIC
[   2ms]
    SCC analysis                              compute [   0ms]  transform [   0ms]
    no return analysis       load [   0ms]    compute [   0ms]  transform [   0ms]
    function inference       load [   0ms]    compute [   0ms]  transform [   0ms]
Printing assembler [   6ms]
```
- use gtirb-pprinter to view the generated gtirb file
```shell
sudo docker run --rm -v $PWD:/workspace -w /workspace grammatech/ddisasm:latest gtirb-pprinter --ir Shootout-nestedloop.gtirb --asm gtirbpprinter-shootout-nestedloop.s
[sudo] password for qingchen: 
[INFO] (/usr/local/src/gtirb-pprinter/src/gtirb_pprinter/driver/pretty_printer.cpp:291)  Reading GTIRB file:     "Shootout-nestedloop.gtirb"
[INFO] (/usr/local/src/gtirb-pprinter/src/gtirb_pprinter/driver/pretty_printer.cpp:577)  Generating assembly file for module Shootout-nestedloop
```
Seems the generated assembly file has minimal differences with the assembly file directly disassembled from the binary
```shell
diff gtirbpprinter-shootout-nestedloop.s Shootout-nestedloop-ddisasm.s 
524a525
> .L_21030:
545d545
< .L_21030:
```
