---
title: Angr notes from Forgo7ten
date: 2024-02-28
categories: [Assembly]
tags: [assembly,python,angr]     # TAG names should always be lowercase
---
此博客转载于 Csdn Forgo7ten [angr学习-笔记汇总](https://blog.csdn.net/Palmer9/article/details/123919530?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-123919530-blog-79467268.235^v43^pc_blog_bottom_relevance_base5&spm=1001.2101.3001.4242.2&utm_relevant_index=4)
===

<div id="article_content" class="article_content clearfix">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css">
                <div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
<h2><a name="t0"></a><a id="angr_4"></a>angr实战</h2> 
<h3><a name="t1"></a><a id="00_angr_find_8"></a>00_angr_find</h3> 
<pre data-index="0" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> angr
p <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/home/cx330/Desktop/Debugging/learn/00_angr_find'</span><span class="token punctuation">,</span>auto_load_libs<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token comment"># 加载文件</span>
<span class="token comment"># auto_load_libs=False   不加载共享库文件</span>

state <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 创建一个状态state</span>
<span class="token comment"># entry_state()  构造一个已经准备好从函数入口点执行的状态。</span>

sm <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simgr<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token comment"># 创建一个Simulation Managers  模拟管理器</span>
<span class="token comment"># 也可改为</span>
<span class="token comment"># sm = p.factory.simulation_manager(state)</span>
<span class="token comment"># 目前没发现区别</span>

good <span class="token operator">=</span> <span class="token number">0x804867d</span>
<span class="token comment"># 正确路径的地址</span>

sm<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find <span class="token operator">=</span> good<span class="token punctuation">)</span>
<span class="token comment"># 让angr开始探索，这个路径</span>
<span class="token comment"># 如果找到了满足find的状态，则将其保存在模拟管理器的found分类里</span>

<span class="token keyword">if</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">:</span>
    <span class="token comment">#如果found分类不为空</span>
    find_state <span class="token operator">=</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token comment"># 就把found分类里面的状态给find_state</span>

flag <span class="token operator">=</span> find_state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment"># state.posix.dumps(0) 获取输入</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># type(flag)为'bytes'，将其转换为字符串再输出</span>


<span class="token comment">####################################</span>
<span class="token comment"># 其中good还可换成</span>
good <span class="token operator">=</span> <span class="token keyword">lambda</span> s<span class="token punctuation">:</span><span class="token string">b'Good Job.'</span> <span class="token keyword">in</span> s<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment"># 意为寻找输出为'Good Job.'的状态，注意这里为字节型数据</span>
<span class="token comment"># # state.posix.dumps(1) 获取输出</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li></ul></pre> 
<h3><a name="t2"></a><a id="01_angr_avoid_52"></a>01_angr_avoid</h3> 
<pre data-index="1" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> angr
p <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/home/cx330/Desktop/Debugging/learn/01_angr_avoid'</span><span class="token punctuation">,</span>auto_load_libs<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token comment"># 加载文件</span>
<span class="token comment"># auto_load_libs=False   不加载共享库文件</span>

state <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 创建一个状态state</span>
<span class="token comment"># entry_state()  构造一个已经准备好从函数入口点执行的状态。</span>

sm <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simulation_manager<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token comment"># 创建一个Simulation Managers  模拟管理器</span>

good <span class="token operator">=</span> <span class="token keyword">lambda</span> s<span class="token punctuation">:</span><span class="token string">b'Good Job.'</span> <span class="token keyword">in</span> s<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment"># 意为寻找输出为'Good Job.'的状态，注意这里为字节型数据</span>
<span class="token comment"># state.posix.dumps(1) 获取输出</span>
<span class="token comment"># 也可换为     good = 0x080485E0  # 即为换成地址</span>

bad <span class="token operator">=</span> <span class="token number">0x080485A8</span>
<span class="token comment">#需要避免的地址，即找到的状态需满足 不执行此地址</span>

sm<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find <span class="token operator">=</span> good<span class="token punctuation">,</span>avoid <span class="token operator">=</span> bad<span class="token punctuation">)</span>
<span class="token comment"># 让angr开始探索，这个路径</span>
<span class="token comment"># 如果找到了满足find和avoid的状态，则将其保存在模拟管理器的found分类里</span>
<span class="token comment"># 如果有经过avoid的状态，将其保存再avoid分类里</span>

<span class="token keyword">if</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">:</span><span class="token comment">#如果found分类里不为空，即存在满足条件的状态，将其去除</span>
    find_state <span class="token operator">=</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
flag <span class="token operator">=</span> find_state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment"># 得到这种状态的输入</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li></ul></pre> 
<h3><a name="t3"></a><a id="02_angr_find_condition_87"></a>02_angr_find_condition</h3> 
<pre data-index="2" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> angr
p <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/home/cx330/Desktop/Debugging/learn/02_angr_find_condition'</span><span class="token punctuation">,</span>auto_load_libs<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
state <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
sm <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simulation_manager<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">is_good</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">b'Good Job'</span> <span class="token keyword">in</span> state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
sm<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find <span class="token operator">=</span> is_good<span class="token punctuation">)</span>
<span class="token keyword">if</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">:</span>
    find_state <span class="token operator">=</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
flag <span class="token operator">=</span> find_state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre> 
<h3><a name="t4"></a><a id="03_angr_symbolic_registers_103"></a>03_angr_symbolic_registers</h3> 
<p>老版angr不支持scanf多个参数(现已支持，因此完全可以用之前的脚本打通……)</p> 
<p>这里使用老版的解法</p> 
<p>main()函数中</p> 
<pre data-index="3" class="set-code-show prettyprint"><code class="prism language-assembly has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">.text:0804897B call    get_user_input
.text:08048980 mov     [ebp+var_14], eax
.text:08048983 mov     [ebp+var_10], ebx
.text:08048986 mov     [ebp+var_C], edx
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<p>可以看到scanf是把三个输入分别给了eax，ebx，edx</p> 
<pre data-index="4" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> angr<span class="token punctuation">,</span>claripy
p <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/home/cx330/Desktop/Debugging/learn/03_angr_symbolic_registers'</span><span class="token punctuation">)</span>
init_addr <span class="token operator">=</span> <span class="token number">0x08048980</span>
state <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>blank_state<span class="token punctuation">(</span>addr<span class="token operator">=</span>init_addr<span class="token punctuation">)</span>
<span class="token comment"># 构造一个空状态，即跳过了scanf，从其下部开始执行</span>

p1 <span class="token operator">=</span> claripy<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span>
p2 <span class="token operator">=</span> claripy<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p2'</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span>
p3 <span class="token operator">=</span> claripy<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p3'</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span>
<span class="token comment"># 定义三个位向量，分别表示三个输入</span>

state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>eax <span class="token operator">=</span> p1
state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>ebx <span class="token operator">=</span> p2
state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>edx <span class="token operator">=</span> p3
<span class="token comment"># 将三个位向量分别给eax，ebx，edx。（因为get_user_input这个函数就是这么干的）</span>

sm <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simulation_manager<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token comment"># 构造一个模拟管理器</span>
<span class="token comment"># def is_bad(state):</span>
<span class="token comment">#        return b'Try again' in state.posix.dumps(1)</span>
<span class="token comment"># 可以加上此约束，即在explore之中加上 avoid = is_bad</span>
<span class="token keyword">def</span> <span class="token function">is_good</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">b'Good Job'</span> <span class="token keyword">in</span> state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
sm<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find <span class="token operator">=</span> is_good<span class="token punctuation">)</span>
<span class="token keyword">if</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">:</span>
    find_state <span class="token operator">=</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    flag1 <span class="token operator">=</span> find_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>
    flag2 <span class="token operator">=</span> find_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span>
    flag3 <span class="token operator">=</span> find_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{:x} {:x} {:x}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>flag1<span class="token punctuation">,</span>flag2<span class="token punctuation">,</span>flag3<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 输出16进制的结果，因为原程序是按照16进制来读取的</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No'</span><span class="token punctuation">)</span>
    <span class="token comment"># 没找到符合条件的状态则输出no</span>

<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li></ul></pre> 
<h3><a name="t5"></a><a id="04_angr_symbolic_stack_158"></a>04_angr_symbolic_stack</h3> 
<p>模拟栈</p> 
<pre data-index="5" class="set-code-show prettyprint"><code class="prism language-assembly has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">.text:08048679 public handle_user
.text:08048679 handle_user proc near
.text:08048679
.text:08048679 var_10= dword ptr -10h
.text:08048679 var_C= dword ptr -0Ch
.text:08048679
.text:08048679 ; __unwind {
.text:08048679 push    ebp
.text:0804867A mov     ebp, esp
.text:0804867C sub     esp, 18h
.text:0804867F sub     esp, 4
.text:08048682 lea     eax, [ebp+var_10]
.text:08048685 push    eax
.text:08048686 lea     eax, [ebp+var_C]
.text:08048689 push    eax
.text:0804868A push    offset aUU      ; "%u %u"
.text:0804868F call    ___isoc99_scanf
.text:08048694 add     esp, 10h
.text:08048697 mov     eax, [ebp+var_C]
.text:0804869A sub     esp, 0Ch
.text:0804869D push    eax
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li></ul></pre> 
<p>假设在scanf函数下执行，08048694为scanf函数恢复栈，所以应从08048697开始模拟</p> 
<pre data-index="6" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> angr
p <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/home/cx330/Desktop/Debugging/learn/04_angr_symbolic_stack'</span><span class="token punctuation">)</span>
<span class="token comment"># 载入程序</span>

<span class="token keyword">def</span> <span class="token function">good</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">b"Good Job."</span> <span class="token keyword">in</span> state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">bad</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">b"Try again."</span> <span class="token keyword">in</span> state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

start_addr <span class="token operator">=</span> <span class="token number">0x08048697</span>
<span class="token comment"># 开始模拟的地址</span>

state <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>blank_state<span class="token punctuation">(</span>addr <span class="token operator">=</span> start_addr<span class="token punctuation">)</span>
<span class="token comment"># 新建一个状态</span>

state<span class="token punctuation">.</span>stack_push<span class="token punctuation">(</span>state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>ebp<span class="token punctuation">)</span>
<span class="token comment"># 压入ebp，模拟地址0x08048679代码</span>

state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>ebp <span class="token operator">=</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>esp
<span class="token comment"># 模拟地址0x0804867A代码</span>

offest <span class="token operator">=</span> <span class="token number">0x8</span>
<span class="token comment"># 两个局部变量</span>
<span class="token comment"># var_C= dword ptr -0Ch  也就是占的地址是 0x9 a b c</span>
<span class="token comment"># var_10= dword ptr -10h 占的地址是 d e f 0x10</span>
state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>esp <span class="token operator">-=</span> offest
<span class="token comment"># 初始化栈</span>

p1 <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span>
p2 <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p2'</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span>
state<span class="token punctuation">.</span>stack_push<span class="token punctuation">(</span>p1<span class="token punctuation">)</span>
state<span class="token punctuation">.</span>stack_push<span class="token punctuation">(</span>p2<span class="token punctuation">)</span>
<span class="token comment"># 创建两个位向量，并将其压入栈</span>

sm <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simgr<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
sm<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find <span class="token operator">=</span> good<span class="token punctuation">,</span> avoid <span class="token operator">=</span> bad<span class="token punctuation">)</span>
<span class="token comment"># 创建模拟管理器并开始探索路径</span>
<span class="token keyword">if</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">:</span>
    found_state <span class="token operator">=</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    flag1 <span class="token operator">=</span> found_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>
    flag2 <span class="token operator">=</span> found_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{} {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>flag1<span class="token punctuation">,</span>flag2<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 输出</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No'</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li></ul></pre> 
<h3><a name="t6"></a><a id="05_angr_symbolic_memory_237"></a>05_angr_symbolic_memory</h3> 
<pre data-index="7" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> angr
p <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/home/cx330/Desktop/Debugging/learn/05_angr_symbolic_memory'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">good</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">b"Good Job."</span> <span class="token keyword">in</span> state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">bad</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">b"Try again."</span> <span class="token keyword">in</span> state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

start_addr <span class="token operator">=</span> <span class="token number">0x08048601</span>
<span class="token comment"># 依旧是选择在scanf函数的下方初始化状态</span>

state <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>blank_state<span class="token punctuation">(</span>addr <span class="token operator">=</span> start_addr<span class="token punctuation">)</span>
p1 <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span>
p2 <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p2'</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span>
p3 <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p3'</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span>
p4 <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'p4'</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span>
state<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>store<span class="token punctuation">(</span><span class="token number">0x0A1BA1C0</span><span class="token punctuation">,</span>p1<span class="token punctuation">)</span>
state<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>store<span class="token punctuation">(</span><span class="token number">0x0A1BA1C8</span><span class="token punctuation">,</span>p2<span class="token punctuation">)</span>
state<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>store<span class="token punctuation">(</span><span class="token number">0x0A1BA1D0</span><span class="token punctuation">,</span>p3<span class="token punctuation">)</span>
state<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>store<span class="token punctuation">(</span><span class="token number">0x0A1BA1D8</span><span class="token punctuation">,</span>p4<span class="token punctuation">)</span>
<span class="token comment"># 初始化四个位向量，并存入内存</span>

sm <span class="token operator">=</span> p<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simgr<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
sm<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find <span class="token operator">=</span> good<span class="token punctuation">,</span> avoid <span class="token operator">=</span> bad<span class="token punctuation">)</span>
<span class="token keyword">if</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">:</span>
    found_state <span class="token operator">=</span> sm<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    flag1 <span class="token operator">=</span> found_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>cast_to<span class="token operator">=</span><span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
    flag2 <span class="token operator">=</span> found_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span>cast_to<span class="token operator">=</span><span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
    flag3 <span class="token operator">=</span> found_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span>cast_to<span class="token operator">=</span><span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
    flag4 <span class="token operator">=</span> found_state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span>cast_to<span class="token operator">=</span><span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
    <span class="token comment"># 先解释成bytes类型再转换成str</span>
    <span class="token comment"># 貌似不能直接转换str</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{} {} {} {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>flag1<span class="token punctuation">,</span>flag2<span class="token punctuation">,</span>flag3<span class="token punctuation">,</span>flag4<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No'</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li></ul></pre> 
<h2><a name="t7"></a><a id="ubuntuangr_282"></a>ubuntu安装angr</h2> 
<ol><li> <p>安装依赖</p> <pre data-index="8" class="set-code-show prettyprint"><code class="prism language-bash has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python-dev libffi-dev build-essential virtualenvwrapper
<span class="token builtin class-name">export</span> <span class="token assign-left variable">WORKON_HOME</span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/Python-workhome
<span class="token builtin class-name">source</span> /usr/share/virtualenvwrapper/virtualenvwrapper.sh
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> </li><li> <p>安装angr</p> </li></ol> 
<pre data-index="9" class="set-code-show prettyprint"><code class="prism language-bash has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">mkvirtualenv angr <span class="token operator">&amp;&amp;</span> pip <span class="token function">install</span> angr
<span class="token punctuation">(</span>或<span class="token punctuation">)</span>
mkvirtualenv --python<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">which</span> python3<span class="token variable">)</span></span> angr <span class="token operator">&amp;&amp;</span> pip <span class="token function">install</span> angr
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> 
<ul><li> <p>若报错：“未找到命令”</p> <p>进行virtualenvwrapper初始化</p> <p>输入</p> <pre data-index="10" class="set-code-show prettyprint"><code class="prism language-bash has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token builtin class-name">export</span> <span class="token assign-left variable">WORKON_HOME</span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/Python-workhome
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> <pre data-index="11" class="set-code-show prettyprint"><code class="prism language-bash has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token builtin class-name">source</span> /usr/share/virtualenvwrapper/virtualenvwrapper.sh
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> </li><li> <p>若报错：ERROR: pyvex 7.8.9.26 has requi rement future=-0.16.0, but you’ll have future 0.18.2 which is incompatible.<br> 将python2和python3的future均改为0.16.0版本<br> 命令：</p> <pre data-index="12" class="set-code-show prettyprint"><code class="prism language-bash has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token function">sudo</span> pip uninstall future
<span class="token function">sudo</span> pip <span class="token function">install</span> <span class="token assign-left variable">future</span><span class="token operator">==</span><span class="token number">0.16</span>.0
<span class="token function">sudo</span> pip3 uninstall future
<span class="token function">sudo</span> pip3 <span class="token function">install</span> <span class="token assign-left variable">future</span><span class="token operator">==</span><span class="token number">0.16</span>.0
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> </li></ul> 
<p>angr的某些组件需要python版本&gt;=3.6</p> 
<p>先<a href="https://so.csdn.net/so/search?q=%E5%8D%87%E7%BA%A7python%E7%89%88%E6%9C%AC&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E5%8D%87%E7%BA%A7python%E7%89%88%E6%9C%AC&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;升级python版本\&quot;}&quot;}" data-tit="升级python版本" data-pretit="升级python版本">升级python版本</a>，若有以下报错</p> 
<pre data-index="13" class="set-code-show prettyprint"><code class="prism language-bash has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 报错</span>
OSError: Command /home/ palmer/.virtualenvs/angr/bin/ python3
SetuptooLs pkg_resources pip wheel failed with error code <span class="token number">2</span>
<span class="token comment"># 解决</span>
<span class="token function">sudo</span> pip <span class="token function">install</span> setuptools
<span class="token function">sudo</span> pip <span class="token function">install</span> --upgrade setuptools
<span class="token function">sudo</span> pip <span class="token function">install</span> virtualenv
<span class="token function">sudo</span> pip <span class="token function">install</span> --upgrade virtualenv

<span class="token comment"># 报错</span>
share/virtuaLenvwrapper/virtualenvwrapper.sh
/usr/bin/python3: Error <span class="token keyword">while</span> finding spec <span class="token keyword">for</span> <span class="token string">'virtualenvwrapper.hook_Loader'</span> <span class="token punctuation">(</span>ImportError: No module named <span class="token string">'virtuaLenvwrapper'</span><span class="token punctuation">)</span>
virtualenvwrapper.sh: There was a problem running the initialization hooks.
<span class="token comment"># 解决</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python3-pip
<span class="token function">sudo</span> pip3 <span class="token function">install</span> virtualenv virtualenvwrapper
<span class="token builtin class-name">source</span> .bashrc

mkvirtualenv --python<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">which</span> python3<span class="token variable">)</span></span> angr

<span class="token comment"># 离线安装pip包cle-8.20.1.7</span>
<span class="token comment"># (如果install angr可以安装，则无需手动安装)</span>

pip <span class="token function">install</span> angr
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li></ul></pre> 
<h2><a name="t8"></a><a id="_357"></a>核心概念</h2> 
<h3><a name="t9"></a><a id="_359"></a>顶层接口</h3> 
<p>使用angr的第一个操作始终是将二进制文件加载到<em>项目中</em>。将使用<code>/bin/true</code>作为以下例子的示例二进制文件。</p> 
<pre data-index="14" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> angr
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/bin/true'</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> 
<p>项目是对angr的控制基础。有了它，将能够对刚加载的可执行文件进行分析和模拟。在Angr中使用的几乎每个对象都将取决于某种形式的项目的存在。</p> 
<h4><a name="t10"></a><a id="_370"></a>基本特性</h4> 
<p>首先，我们具有一些该项目的基本属性：其<a href="https://so.csdn.net/so/search?q=CPU%E6%9E%B6%E6%9E%84&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=CPU%E6%9E%B6%E6%9E%84&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;CPU架构\&quot;}&quot;}" data-tit="CPU架构" data-pretit="cpu架构">CPU架构</a>，其文件名以及其入口点的地址。</p> 
<pre data-index="15" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> monkeyhex <span class="token comment"># 这将格式化十六进制数值结果</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>arch
<span class="token operator">&lt;</span>Arch AMD64 <span class="token punctuation">(</span>LE<span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>entry
<span class="token number">0x401670</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>filename
<span class="token string">'/bin/true'</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<ul><li><code>proj.arch</code>：arch是archinfo.Arch对象的一个实例，<strong>表示程序指令架构</strong>，在本例中是AMD64小端，一般会关心 arch.bits, arch.bytes,arch.name与arch.memory_endness。</li><li><code>proj.entry</code>：二进制文件的入口</li><li><code>proj.filename</code>：二进制文件的文件名</li></ul> 
<h4><a name="t11"></a><a id="_388"></a>加载器</h4> 
<p>angr使用CLE模块将二进制文件映射到虚拟地址空间，CLE得到的结果作为<code>.loader</code>属性,可以通过它查看与程序一起加载的angr共享库以及加载地址空间的一些信息</p> 
<pre data-index="16" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader  <span class="token comment"># &amp;将其加载到内存</span>
<span class="token operator">&lt;</span>Loaded true<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x400000</span><span class="token punctuation">:</span><span class="token number">0x5004000</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>shared_objects <span class="token comment"># &amp;共享库</span>
<span class="token punctuation">{<!-- --></span><span class="token string">'ld-linux-x86-64.so.2'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>ELF Object ld<span class="token operator">-</span><span class="token number">2.24</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x2000000</span><span class="token punctuation">:</span><span class="token number">0x2227167</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token string">'libc.so.6'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>ELF Object libc<span class="token operator">-</span><span class="token number">2.24</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x1000000</span><span class="token punctuation">:</span><span class="token number">0x13c699f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">}</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>min_addr  <span class="token comment"># &amp;内存中最小地址</span>
<span class="token number">0x400000</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>max_addr  <span class="token comment"># &amp;内存中最大的地址</span>
<span class="token number">0x5004000</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>main_object  <span class="token comment"># 我们在这个项目中加载了几个二进制文件。这是最主要的那一个。</span>
<span class="token operator">&lt;</span>ELF Object true<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x400000</span><span class="token punctuation">:</span><span class="token number">0x60721f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>main_object<span class="token punctuation">.</span>execstack  <span class="token comment"># 示例查询:这个二进制文件有可执行堆栈吗?</span>
<span class="token boolean">False</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>main_object<span class="token punctuation">.</span>pic  <span class="token comment"># 示例查询:这个二进制独立吗?(is this binary position-independent?)</span>
<span class="token boolean">True</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li></ul></pre> 
<h4><a name="t12"></a><a id="The_factory_414"></a>The factory</h4> 
<p>angr里面定义了许多类，大多数类都需要使用project来实例化。为了不使你的代码里到处都是project，我们提供一个<code>project.factory</code> 对象，它为一些你经常使用的对象内置了一些方便的构造函数。</p> 
<h5><a id="Blocks_418"></a>Blocks</h5> 
<p>我们有<code>project.factory.block()</code>，用于从给定地址提取基本代块。</p> 
<pre data-index="17" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> block <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>block<span class="token punctuation">(</span>proj<span class="token punctuation">.</span>entry<span class="token punctuation">)</span> <span class="token comment"># 取出一块代码 从程序的入口点</span>
<span class="token operator">&lt;</span>Block <span class="token keyword">for</span> <span class="token number">0x401670</span><span class="token punctuation">,</span> <span class="token number">42</span> <span class="token builtin">bytes</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> block<span class="token punctuation">.</span>pp<span class="token punctuation">(</span><span class="token punctuation">)</span>                          <span class="token comment"># 将反汇编打印到标准输出</span>
<span class="token number">0x401670</span><span class="token punctuation">:</span>       xor     ebp<span class="token punctuation">,</span> ebp
<span class="token number">0x401672</span><span class="token punctuation">:</span>       mov     r9<span class="token punctuation">,</span> rdx
<span class="token number">0x401675</span><span class="token punctuation">:</span>       pop     rsi
<span class="token number">0x401676</span><span class="token punctuation">:</span>       mov     rdx<span class="token punctuation">,</span> rsp
<span class="token number">0x401679</span><span class="token punctuation">:</span>       <span class="token keyword">and</span>     rsp<span class="token punctuation">,</span> <span class="token number">0xfffffffffffffff0</span>
<span class="token number">0x40167d</span><span class="token punctuation">:</span>       push    rax
<span class="token number">0x40167e</span><span class="token punctuation">:</span>       push    rsp
<span class="token number">0x40167f</span><span class="token punctuation">:</span>       lea     r8<span class="token punctuation">,</span> <span class="token punctuation">[</span>rip <span class="token operator">+</span> <span class="token number">0x2e2a</span><span class="token punctuation">]</span>
<span class="token number">0x401686</span><span class="token punctuation">:</span>       lea     rcx<span class="token punctuation">,</span> <span class="token punctuation">[</span>rip <span class="token operator">+</span> <span class="token number">0x2db3</span><span class="token punctuation">]</span>
<span class="token number">0x40168d</span><span class="token punctuation">:</span>       lea     rdi<span class="token punctuation">,</span> <span class="token punctuation">[</span>rip <span class="token operator">-</span> <span class="token number">0xd4</span><span class="token punctuation">]</span>
<span class="token number">0x401694</span><span class="token punctuation">:</span>       call    qword ptr <span class="token punctuation">[</span>rip <span class="token operator">+</span> <span class="token number">0x205866</span><span class="token punctuation">]</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> block<span class="token punctuation">.</span>instructions                  <span class="token comment"># 此块代码 拥有的指令数</span>
<span class="token number">0xb</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> block<span class="token punctuation">.</span>instruction_addrs             <span class="token comment"># 此块代码 每条指令的起始4地址</span>
<span class="token punctuation">[</span><span class="token number">0x401670</span><span class="token punctuation">,</span> <span class="token number">0x401672</span><span class="token punctuation">,</span> <span class="token number">0x401675</span><span class="token punctuation">,</span> <span class="token number">0x401676</span><span class="token punctuation">,</span> <span class="token number">0x401679</span><span class="token punctuation">,</span> <span class="token number">0x40167d</span><span class="token punctuation">,</span> <span class="token number">0x40167e</span><span class="token punctuation">,</span> <span class="token number">0x40167f</span><span class="token punctuation">,</span> <span class="token number">0x401686</span><span class="token punctuation">,</span> <span class="token number">0x40168d</span><span class="token punctuation">,</span> <span class="token number">0x401694</span><span class="token punctuation">]</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li></ul></pre> 
<p>此外，你可以通过<code>block</code>得到代码块的其他表示形式</p> 
<pre data-index="18" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> block<span class="token punctuation">.</span>capstone                       <span class="token comment"># capstone disassembly &amp;啥啥啥反汇编？</span>
<span class="token operator">&lt;</span>CapstoneBlock <span class="token keyword">for</span> <span class="token number">0x401670</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> block<span class="token punctuation">.</span>vex                            <span class="token comment"># VEX IRSB(这是python内部地址，不是程序地址)</span>
<span class="token operator">&lt;</span>pyvex<span class="token punctuation">.</span>block<span class="token punctuation">.</span>IRSB at <span class="token number">0x7706330</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<h5><a id="States_454"></a>States（状态）</h5> 
<p>Project对象只代表程序的一个初始化镜像，当你使用angr来执行时，你使用的是表示模拟程序状态的特定对象<code>SimState</code>。</p> 
<pre data-index="19" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>SimState @ <span class="token number">0x401670</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> 
<p>一个SimState包括程序内存，寄存器，文件系统数据…任何可以通过执行来更改的“活动数据”在<code>state</code>中都可以找到。现在我们可以使用<code>state.regs</code>and <code>state.mem</code></p> 
<pre data-index="20" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rip        <span class="token comment"># 获取当前指令指针，即当前执行到的代码地址，或者说获取EIP寄存器里存储的值</span>
<span class="token operator">&lt;</span>BV64 <span class="token number">0x401670</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rax
<span class="token operator">&lt;</span>BV64 <span class="token number">0x1c</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>mem<span class="token punctuation">[</span>proj<span class="token punctuation">.</span>entry<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">.</span>resolved  <span class="token comment"># &amp;将入口点的内存地址解释成C int数据(interpret the memory at the entry point as a C int)</span>
<span class="token operator">&lt;</span>BV32 <span class="token number">0x8949ed31</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li></ul></pre> 
<ul><li><code>state.regs</code>：寄存器</li><li><code>state.mem</code>：内存地址</li></ul> 
<p>这些是bitvector变量。可以把它看作是一个整数，用一系列位来表示，在angr里用来表示CPU数据。注意，每个位向量都有一个<code>.length</code>属性，以位为单位描述它的宽度。</p> 
<p>这里是如何将python int转换为位向量，然后再转换回来：</p> 
<pre data-index="21" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> bv <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVV<span class="token punctuation">(</span><span class="token number">0x1234</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span>       <span class="token comment"># 创建一个32位宽的bitvector变量,其值为0x1234</span>
<span class="token operator">&lt;</span>BV32 <span class="token number">0x1234</span><span class="token operator">&gt;</span>                               <span class="token comment"># BVV stands for bitvector value</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>bv<span class="token punctuation">)</span>                <span class="token comment"># 转换为python int变量</span>
<span class="token number">0x1234</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<p>你可以把这些bitvector赋给寄存器或内存，或者直接赋值整数，它将被自动转为合适大小的bitvector</p> 
<pre data-index="22" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rsi <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVV<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rsi
<span class="token operator">&lt;</span>BV64 <span class="token number">0x3</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>mem<span class="token punctuation">[</span><span class="token number">0x1000</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">long</span> <span class="token operator">=</span> <span class="token number">4</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>mem<span class="token punctuation">[</span><span class="token number">0x1000</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">.</span>resolved
<span class="token operator">&lt;</span>BV64 <span class="token number">0x4</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<p>其中mem的简短使用方式为：</p> 
<ol><li>使用array[index]的形式来指定地址；</li><li>使用<code>.&lt;type&gt;</code>来指定内存需要解释为的类型<code>(char, short, int, long, size_t, uint8_t, uint16_t...)</code>；</li><li>通过它 
  <ul><li>你可以存入一个值(bitvector或python int)</li><li><code>.resolved</code>来获取<code>bitvector</code>值</li><li><code>.concrete</code>来获取<code>python int</code>值。</li></ul> </li></ol> 
<p>如果你尝试访问更多的寄存器，你将会发现一些奇怪的值。</p> 
<pre data-index="23" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rdi
<span class="token operator">&lt;</span>BV64 reg_48_11_64<span class="token punctuation">{<!-- --></span>UNINITIALIZED<span class="token punctuation">}</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> 
<p>这还是一个64位的位向量，但是里面并没有存储一个数值，取而代之的是一个名字！这被称为“符号变量”，并且这是符号化执行的基础。</p> 
<h5><a id="Simulation_Managers_518"></a>仿真管理器(Simulation Managers)</h5> 
<p>如果一个state使我们能够为我们实时呈现一个程序的执行状态，那么就必须有一个方法使我们达到程序执行的下一个状态。一个“仿真管理器”是angr中使用state来实现执行(模拟，或者任何你喜欢的称呼)的基本接口。作为一个简要的介绍，我们展示如何让我们之前创建的state实例“前进”几个基本块。</p> 
<p>首先，我们创建一个将会使用到的SM。构造函数接收一个state或一个state的列表作为参数：</p> 
<pre data-index="24" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simulation_manager<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>SimulationManager <span class="token keyword">with</span> <span class="token number">1</span> active<span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>active
<span class="token punctuation">[</span><span class="token operator">&lt;</span>SimState @ <span class="token number">0x401670</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<p>一个SM可能包含多个存储state的列表。默认的列表是<code>active</code>，它和我们传入的state（或state的列表）一起被初始化。如果我们觉得不够的话，可以看看<code>simgr.active[0]</code>来看看我们当前的状态信息。</p> 
<p>现在……做一些执行操作。</p> 
<pre data-index="25" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">simgr<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<p>我们刚刚演示了执行一个可符号化执行的基本块！我们可以再看看active列表，注意到它已经被更新了，并且不仅如此，它没有修改我们的初始状态。SimState对象在执行时被视为“不可变”的——你可以安全地将一个单独的state作为多轮执行的一个“基点”。</p> 
<pre data-index="26" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>active
<span class="token punctuation">[</span><span class="token operator">&lt;</span>SimState @ <span class="token number">0x1020300</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>active<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rip                 <span class="token comment"># 崭新的值</span>
<span class="token operator">&lt;</span>BV64 <span class="token number">0x1020300</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rip                           <span class="token comment"># 依旧相同</span>
<span class="token operator">&lt;</span>BV64 <span class="token number">0x401670</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li></ul></pre> 
<h4><a name="t13"></a><a id="Analyses_550"></a>分析器（Analyses）</h4> 
<p>angr封装了一些可能会被用来从程序中提取一些有趣信息的内置分析工具。</p> 
<pre data-index="27" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>            <span class="token comment"># 在ipython中按TAB键可以得到所有内容的自动补全列表:</span>
 proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>BackwardSlice        proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>CongruencyCheck      proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>reload_analyses       
 proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>BinaryOptimizer      proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>DDG                  proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>StaticHooker          
 proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>BinDiff              proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>DFG                  proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>VariableRecovery      
 proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>BoyScout             proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>Disassembly          proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>VariableRecoveryFast  
 proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>CDG                  proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>GirlScout            proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>Veritesting           
 proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>CFG                  proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>Identifier           proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>VFG                   
 proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>CFGEmulated          proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>LoopFinder           proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>VSA_DDG               
 proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>CFGFast              proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>Reassembler
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre> 
<p>下面是如何能够创建并使用一个快速的程序控制流程图的例子：</p> 
<pre data-index="28" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 最初，当我们加载这个二进制文件时，它也将所有依赖项加载到同一个虚拟地址空间中</span>
<span class="token comment"># 这对于大多数分析来说是不可取的。</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/bin/true'</span><span class="token punctuation">,</span> auto_load_libs<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> cfg <span class="token operator">=</span> proj<span class="token punctuation">.</span>analyses<span class="token punctuation">.</span>CFGFast<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>CFGFast Analysis Result at <span class="token number">0x2d85130</span><span class="token operator">&gt;</span>

<span class="token comment"># cfg.graph is a networkx DiGraph full of CFGNode instances</span>
<span class="token comment"># 您应该去查询networkx api来学习如何使用它!</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> cfg<span class="token punctuation">.</span>graph
<span class="token operator">&lt;</span>networkx<span class="token punctuation">.</span>classes<span class="token punctuation">.</span>digraph<span class="token punctuation">.</span>DiGraph at <span class="token number">0x2da43a0</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>nodes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">951</span>

<span class="token comment"># 要获取给定地址的CFGNode，使用 cfg.get_any_node</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> entry_node <span class="token operator">=</span> cfg<span class="token punctuation">.</span>get_any_node<span class="token punctuation">(</span>proj<span class="token punctuation">.</span>entry<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>successors<span class="token punctuation">(</span>entry_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">2</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li></ul></pre> 
<h3><a name="t14"></a><a id="Loading_a_Binary_590"></a>加载一个二进制文件(Loading a Binary)</h3> 
<p>我们简要提到了angr的二进制加载组件，CLE。CLE代表“CLE Loads Everything”，负责加载二进制文件（以及任何这个文件以来的库），并用一种容易操作的方式将它们展示给angr的其余组件。</p> 
<h4><a name="t15"></a><a id="_The_Loader_594"></a>加载器 (The Loader)</h4> 
<p>让我们重新加载<code>examples/fauxware/fauxware</code>并且深入学习如何和loader交互：</p> 
<pre data-index="29" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> angr<span class="token punctuation">,</span> monkeyhex
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'examples/fauxware/fauxware'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader
<span class="token operator">&lt;</span>Loaded fauxware<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x400000</span><span class="token punctuation">:</span><span class="token number">0x5008000</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<h5><a id="Loaded_Objects_605"></a>已加载的对象(Loaded Objects)</h5> 
<p>CLE加载器(<code>cle.Loader</code>)代表一整个被加载的二进制对象的集合，它们被加载并且映射到同一个内存空间中。每一个二进制对象都被一个能够处理对应文件类型(<code>cle.Backend</code>的子类)的加载器后端加载。比如，<code>cle.ELF</code>被用来加载ELF格式的二进制文件。</p> 
<p>内存中也会有一些和任何被加载的二进制文件都无关的对象。比如，被用来提供线程本地存储(Thread-Local storage)支持的对象和用于提供未解析的符号的外部对象。</p> 
<p>你可以使用<code>loader.all_objects</code>来获取CLE已经加载的所有对象，也可以指定更加具体的类别来访问这些对象：</p> 
<pre data-index="30" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 所有加载对象</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>all_objects
<span class="token punctuation">[</span><span class="token operator">&lt;</span>ELF Object fauxware<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x400000</span><span class="token punctuation">:</span><span class="token number">0x60105f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>ELF Object libc<span class="token operator">-</span><span class="token number">2.23</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x1000000</span><span class="token punctuation">:</span><span class="token number">0x13c999f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>ELF Object ld<span class="token operator">-</span><span class="token number">2.23</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x2000000</span><span class="token punctuation">:</span><span class="token number">0x2227167</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>ELFTLSObject Object cle<span class="token comment">##tls, maps [0x3000000:0x3015010]&gt;,</span>
 <span class="token operator">&lt;</span>ExternObject Object cle<span class="token comment">##externs, maps [0x4000000:0x4008000]&gt;,</span>
 <span class="token operator">&lt;</span>KernelObject Object cle<span class="token comment">##kernel, maps [0x5000000:0x5008000]&gt;]</span>

<span class="token comment"># 这是“main”对象，是您在加载项目时直接指定的对象</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>main_object
<span class="token operator">&lt;</span>ELF Object fauxware<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x400000</span><span class="token punctuation">:</span><span class="token number">0x60105f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>

<span class="token comment"># 这是一个从共享对象名到对象的字典映射</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>shared_objects
<span class="token punctuation">{<!-- --></span> <span class="token string">'fauxware'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>ELF Object fauxware<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x400000</span><span class="token punctuation">:</span><span class="token number">0x60105f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token string">'libc.so.6'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>ELF Object libc<span class="token operator">-</span><span class="token number">2.23</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x1000000</span><span class="token punctuation">:</span><span class="token number">0x13c999f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token string">'ld-linux-x86-64.so.2'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>ELF Object ld<span class="token operator">-</span><span class="token number">2.23</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x2000000</span><span class="token punctuation">:</span><span class="token number">0x2227167</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">}</span>

<span class="token comment"># 这是所有从ELF文件中加载的对象</span>
<span class="token comment"># 如果这是一个windows程序，我们会使用 all_pe_objects</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>all_elf_objects
<span class="token punctuation">[</span><span class="token operator">&lt;</span>ELF Object fauxware<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x400000</span><span class="token punctuation">:</span><span class="token number">0x60105f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>ELF Object libc<span class="token operator">-</span><span class="token number">2.23</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x1000000</span><span class="token punctuation">:</span><span class="token number">0x13c999f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token operator">&lt;</span>ELF Object ld<span class="token operator">-</span><span class="token number">2.23</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x2000000</span><span class="token punctuation">:</span><span class="token number">0x2227167</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>

<span class="token comment"># 这是“externs对象”，我们使用它为未解析的导入和angr内部提供地址</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>extern_object
<span class="token operator">&lt;</span>ExternObject Object cle<span class="token comment">##externs, maps [0x4000000:0x4008000]&gt;</span>

<span class="token comment"># 此对象用于为模拟的系统调用提供地址</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>kernel_object
<span class="token operator">&lt;</span>KernelObject Object cle<span class="token comment">##kernel, maps [0x5000000:0x5008000]&gt;</span>

<span class="token comment"># 最后，您可以获得一个对象的引用，该对象中有一个地址</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>find_object_containing<span class="token punctuation">(</span><span class="token number">0x400000</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ELF Object fauxware<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x400000</span><span class="token punctuation">:</span><span class="token number">0x60105f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li></ul></pre> 
<p>你可以直接与这些对象交互，从它们中提取元数据:</p> 
<pre data-index="31" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj <span class="token operator">=</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>main_object

<span class="token comment"># 对象的入口点</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>entry
<span class="token number">0x400580</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>min_addr<span class="token punctuation">,</span> obj<span class="token punctuation">.</span>max_addr
<span class="token punctuation">(</span><span class="token number">0x400000</span><span class="token punctuation">,</span> <span class="token number">0x60105f</span><span class="token punctuation">)</span>

<span class="token comment"># 获取ELF的内存分段和文件分段：</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>segments
<span class="token operator">&lt;</span>Regions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>ELFSegment memsize<span class="token operator">=</span><span class="token number">0xa74</span><span class="token punctuation">,</span> filesize<span class="token operator">=</span><span class="token number">0xa74</span><span class="token punctuation">,</span> vaddr<span class="token operator">=</span><span class="token number">0x400000</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">0x5</span><span class="token punctuation">,</span> offset<span class="token operator">=</span><span class="token number">0x0</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
           <span class="token operator">&lt;</span>ELFSegment memsize<span class="token operator">=</span><span class="token number">0x238</span><span class="token punctuation">,</span> filesize<span class="token operator">=</span><span class="token number">0x228</span><span class="token punctuation">,</span> vaddr<span class="token operator">=</span><span class="token number">0x600e28</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">0x6</span><span class="token punctuation">,</span> offset<span class="token operator">=</span><span class="token number">0xe28</span><span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>sections
<span class="token operator">&lt;</span>Regions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>Unnamed <span class="token operator">|</span> offset <span class="token number">0x0</span><span class="token punctuation">,</span> vaddr <span class="token number">0x0</span><span class="token punctuation">,</span> size <span class="token number">0x0</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
           <span class="token operator">&lt;</span><span class="token punctuation">.</span>interp <span class="token operator">|</span> offset <span class="token number">0x238</span><span class="token punctuation">,</span> vaddr <span class="token number">0x400238</span><span class="token punctuation">,</span> size <span class="token number">0x1c</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
           <span class="token operator">&lt;</span><span class="token punctuation">.</span>note<span class="token punctuation">.</span>ABI<span class="token operator">-</span>tag <span class="token operator">|</span> offset <span class="token number">0x254</span><span class="token punctuation">,</span> vaddr <span class="token number">0x400254</span><span class="token punctuation">,</span> size <span class="token number">0x20</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>etc

<span class="token comment"># 你可以得到一个单独的段或节地址，它包含:</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>find_segment_containing<span class="token punctuation">(</span>obj<span class="token punctuation">.</span>entry<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ELFSegment memsize<span class="token operator">=</span><span class="token number">0xa74</span><span class="token punctuation">,</span> filesize<span class="token operator">=</span><span class="token number">0xa74</span><span class="token punctuation">,</span> vaddr<span class="token operator">=</span><span class="token number">0x400000</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token number">0x5</span><span class="token punctuation">,</span> offset<span class="token operator">=</span><span class="token number">0x0</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>find_section_containing<span class="token punctuation">(</span>obj<span class="token punctuation">.</span>entry<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token punctuation">.</span>text <span class="token operator">|</span> offset <span class="token number">0x580</span><span class="token punctuation">,</span> vaddr <span class="token number">0x400580</span><span class="token punctuation">,</span> size <span class="token number">0x338</span><span class="token operator">&gt;</span>

<span class="token comment"># 获取PLT表信息</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> addr <span class="token operator">=</span> obj<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'strcmp'</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> addr
<span class="token number">0x400550</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>reverse_plt<span class="token punctuation">[</span>addr<span class="token punctuation">]</span>
<span class="token string">'strcmp'</span>

<span class="token comment"># 展示预链接基址和实际装载到的内存基址，它实际上是映射到内存中的CLE</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>linked_base
<span class="token number">0x400000</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> obj<span class="token punctuation">.</span>mapped_base
<span class="token number">0x400000</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li></ul></pre> 
<h5><a id="Symbols_and_Relocations_695"></a>符号和重定位(Symbols and Relocations)</h5> 
<p>在使用CLE的同时也可以使用符号。一个“符号”在形式化执行的世界中是一个基础概念，它将一个名字有效地(effectively)映射到一个地址。</p> 
<p>从CLE中获取符号，最简单的方法是使用<code>loader.find_symbol</code>， 它接收一个名字或者一个地址并返回一个符号对象。</p> 
<pre data-index="32" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp <span class="token operator">=</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>find_symbol<span class="token punctuation">(</span><span class="token string">'strcmp'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp
<span class="token operator">&lt;</span>Symbol <span class="token string">"strcmp"</span> <span class="token keyword">in</span> libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> at <span class="token number">0x1089cd0</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> 
<p>一个符号最有用的属性是它的名字、父对象(owner)、和它的地址。但是一个符号的“地址”却是一个含糊的概念。有三种方式来准确表述一个符号的“地址”：</p> 
<ul><li><code>.rebased_addr</code> 是一个符号在全局地址空间中的地址。这就是你直接打印<code>symbol.addr</code>会显示的内容。</li><li><code>.linked_addr</code>是符号相对于二进制文件预链接基址的地址，这个地址和用诸如readelf(1)显示的地址是一样的。</li><li><code>.relative_addr</code>是符号相对于对象基址的地址。在一些文献中(尤其在windows的文献中)，这样的地址被称为RVA(相对虚拟地址)</li></ul> 
<pre data-index="33" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp<span class="token punctuation">.</span>name
<span class="token string">'strcmp'</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp<span class="token punctuation">.</span>owner
<span class="token operator">&lt;</span>ELF Object libc<span class="token operator">-</span><span class="token number">2.23</span><span class="token punctuation">.</span>so<span class="token punctuation">,</span> maps <span class="token punctuation">[</span><span class="token number">0x1000000</span><span class="token punctuation">:</span><span class="token number">0x13c999f</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp<span class="token punctuation">.</span>rebased_addr
<span class="token number">0x1089cd0</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp<span class="token punctuation">.</span>linked_addr
<span class="token number">0x89cd0</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp<span class="token punctuation">.</span>relative_addr
<span class="token number">0x89cd0</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li></ul></pre> 
<p>除了提供调试信息外，符号还支持动态链接的概念。libc将strcmp符号作为导出提供，主要的二进制文件依赖于它。如果我们要求CLE直接从主对象中给我们一个strcmp符号，它会告诉我们这是一个导入符号。导入符号没有与它们相关联的有意义的地址，但是它们提供了对用于解析它们的符号的引用，如<code>.resolvedby</code>。</p> 
<pre data-index="34" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp<span class="token punctuation">.</span>is_export
<span class="token boolean">True</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> strcmp<span class="token punctuation">.</span>is_import
<span class="token boolean">False</span>

<span class="token comment"># 在之前的loader中，我们使用find_symbol方法，因为它执行一个搜索操作来找到指定的符号</span>
<span class="token comment"># 在一个独立的对象中，这个方法是get_symbol，因为一个给定的名字只会对应一个符号</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> main_strcmp <span class="token operator">=</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>main_object<span class="token punctuation">.</span>get_symbol<span class="token punctuation">(</span><span class="token string">'strcmp'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> main_strcmp
<span class="token operator">&lt;</span>Symbol <span class="token string">"strcmp"</span> <span class="token keyword">in</span> fauxware <span class="token punctuation">(</span><span class="token keyword">import</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> main_strcmp<span class="token punctuation">.</span>is_export
<span class="token boolean">False</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> main_strcmp<span class="token punctuation">.</span>is_import
<span class="token boolean">True</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> main_strcmp<span class="token punctuation">.</span>resolvedby
<span class="token operator">&lt;</span>Symbol <span class="token string">"strcmp"</span> <span class="token keyword">in</span> libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> at <span class="token number">0x1089cd0</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li></ul></pre> 
<p>导入符号(import symbol)和导出符号(export symbol)的关系应该在内存中以一种特殊的方式被记录，这种方式引出另一种特殊的概念——“重定位”。“重定位”说的是：当你将一个[import]和一个导出符号匹配的时候，请将导出符号的地址按照[format]的形式写到[location]。我们可以通过<code>obj.relocs</code>(获取<code>Relocation</code>实例)看到一个对象的完成重定位表，或者通过<code>obj.imports</code>看到符号名和他们的重定位地址的映射关系。对于导出符号表，angr中没有相应对象与之对应。一个对象中需要重定位的相应导入符号可以用<code>.symbol</code>获取。重定位将会写入的地址可以通过访问一个Symbol的地址的任何方式获取，你还可以通过<code>.owner_obj</code>来获得一个请求重定位的对象的引用。</p> 
<pre data-index="35" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 重定位没有良好的漂亮打印，所以这些地址是python内部的，与我们的程序无关</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>shared_objects<span class="token punctuation">[</span><span class="token string">'libc.so.6'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>imports
<span class="token punctuation">{<!-- --></span><span class="token string">'__libc_enable_secure'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>cle<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>elf<span class="token punctuation">.</span>relocation<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>R_X86_64_GLOB_DAT at <span class="token number">0x7ff5c5fce780</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token string">'__tls_get_addr'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>cle<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>elf<span class="token punctuation">.</span>relocation<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>R_X86_64_JUMP_SLOT at <span class="token number">0x7ff5c6018358</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token string">'_dl_argv'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>cle<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>elf<span class="token punctuation">.</span>relocation<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>R_X86_64_GLOB_DAT at <span class="token number">0x7ff5c5fd2e48</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token string">'_dl_find_dso_for_object'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>cle<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>elf<span class="token punctuation">.</span>relocation<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>R_X86_64_JUMP_SLOT at <span class="token number">0x7ff5c6018588</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token string">'_dl_starting_up'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>cle<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>elf<span class="token punctuation">.</span>relocation<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>R_X86_64_GLOB_DAT at <span class="token number">0x7ff5c5fd2550</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token string">'_rtld_global'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>cle<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>elf<span class="token punctuation">.</span>relocation<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>R_X86_64_GLOB_DAT at <span class="token number">0x7ff5c5fce4e0</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
 <span class="token string">'_rtld_global_ro'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>cle<span class="token punctuation">.</span>backends<span class="token punctuation">.</span>elf<span class="token punctuation">.</span>relocation<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>R_X86_64_GLOB_DAT at <span class="token number">0x7ff5c5fcea20</span><span class="token operator">&gt;</span><span class="token punctuation">}</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre> 
<p>如果一个导入符号不能被解析为任何导出符号，比如找不到对应的共享库文件，CLE将会自动更新<code>loader.extern_obj</code>来表明这个符号由CLE导出。</p> 
<h4><a name="t16"></a><a id="Loading_Options_765"></a>加载选项(Loading Options)</h4> 
<p>如果你正在使用<code>angr.Project</code>加载一些东西并且你想要给<code>cle.loader</code>实例传一个选项来创建Project，你可以直接传入关键字参数给Project的构造函数，你传入的关键字就会被传给CLE。如果你想要知道所有能够被作为选项传入的参数，你可以查看<a href="http://angr.io/api-doc/cle.html" rel="nofollow">CLE的API文档</a>。在本文档中，我们只看一些重要的并且被频繁使用的选项。</p> 
<h5><a id="_769"></a>基本选项</h5> 
<p>我们已经用过了<code>auto_load_libs</code>选项——它控制CLE是否自动加载共享库文件，默认是自动加载的。另外，有一个相反的选项<code>except_missing_libs</code>,这个选项如果被设置为true，将在二进制包含无法解析的共享库时抛出一个异常。</p> 
<p>你可以传入一个字符串列表给<code>force_load_libs</code>选项，每一个被列出的字符串将会被当做一个不可解析共享库依赖，或者你可以传入一个字符串列表给<code>skip_libs</code>来防止列表列出的共享库的被作为依赖添加。另外，你可以传入一个字符串列表给<code>custom_ld_path</code>选项，这个选项中的字符串会被作为额外的搜索共享库文件的路径，这些路径将会比任何默认路径先被搜索，默认路径包括：被加载文件所在的路径，当前工作路径，系统库路径。</p> 
<h5><a id="PerBinary__775"></a>Per-Binary 选项</h5> 
<p>如果你想要对一个特定的二进制对象设置一些选项，CLE也能满足你的需求。参数<code>main_opts</code>和<code>lib_opts</code>接收一个以python字典形式存储的选项组。<code>main_opts</code>接收一个形如{选项名1：选项值1，选项名2：选项值2……}的字典，而<code>lib_opts</code>接收一个库名到形如{选项名1:选项值1，选项名2:选项值2……}的字典的映射。</p> 
<p>这些选项的内容因不同的后台而异，下面是一些通用的选项：</p> 
<ul><li>backend —— 使用哪个后台，可以是一个对象，也可以是一个名字(字符串)</li><li>custom_base_addr —— 使用的基地址</li><li>custom_entry_point —— 使用的入口点</li><li>custom_arch —— 使用的处理器体系结构的名字</li></ul> 
<pre data-index="36" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'examples/fauxware/fauxware'</span><span class="token punctuation">,</span> main_opts<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'backend'</span><span class="token punctuation">:</span> <span class="token string">'blob'</span><span class="token punctuation">,</span> <span class="token string">'arch'</span><span class="token punctuation">:</span> <span class="token string">'i386'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> lib_opts<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'libc.so.6'</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span><span class="token string">'backend'</span><span class="token punctuation">:</span> <span class="token string">'elf'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Project examples<span class="token operator">/</span>fauxware<span class="token operator">/</span>fauxware<span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> 
<h5><a id="Backends_791"></a>后台（Backends）</h5> 
<p>CLE目前有能够静态加载ELF,PE,CGC,Mach-O和ELF核心转储文件的后台，并且支持使用IDA加载二进制和加载文件到一个平坦地址空间。大部分情况下，CLE将会自动检测二进制文件来决定使用哪个后台，所以除非你在做一些很奇怪的工作，一般情况下你不需要指定使用哪个后台。</p> 
<p>你可以和上一节描述的一样，用传入一个键的方式强制CLE使用指定的后台。一些后台不能被自动检测，因此必须用<code>custom_arch</code>指定。键值不需要匹配任何一个架构：根据你给出的任意架构的任意通用标识符，angr都能够识别出你指的是哪个架构。</p> 
<p>为了指定使用的后台，使用下表列出的名字：</p> 
<div class="table-box"><table><thead><tr><th>名字</th><th>描述</th><th>是否需要用custom_arch指定?</th></tr></thead><tbody><tr><td>elf</td><td>基于PyELFTools的ELF文件静态加载器</td><td>不需要</td></tr><tr><td>pe</td><td>基于PEFile的静态PE文件加载器</td><td>不需要</td></tr><tr><td>mach-o</td><td>Mach-O文件的静态加载器，不支持动态链接或者变基</td><td>不需要</td></tr><tr><td>cgc</td><td>Cyber Grand Challenge系统中的二进制文件的静态加载器</td><td>不需要</td></tr><tr><td>backedcgc</td><td>允许指定内存和寄存器支持的CGC二进制文件静态加载器</td><td>不需要</td></tr><tr><td>elfcore</td><td>ELF核心转储文件的静态加载器</td><td>不需要</td></tr><tr><td>ida</td><td>启动ida来分析文件</td><td>需要</td></tr><tr><td>blob</td><td>按照平坦模式加载文件到内存中</td><td>需要</td></tr></tbody></table></div> 
<h4><a name="t17"></a><a id="Symbolic_Function_Summaries_810"></a>符号函数摘要集(Symbolic Function Summaries)</h4> 
<p>默认情况下，Project都会尝试用SimProcedures这个符号摘要集(symbolic summaries)替换主程序的外部调用。SimProcedure使用<br> pyhton函数高效地模拟外部库函数对state的影响。我们已经在SimProcedure中实现了<a href="https://github.com/angr/angr/tree/master/angr/procedures">一个完整的函数集<br> </a>。这些内建过程(procedures)能够在<code>angr.SIM_PROCEDURES</code>字典中获得，这个字典是一个两层结构，第一层的键是包名(libc,posix,win32,stubs)，第二层的键是库函数的名字。用SimProcedure替代实际库函数的执行虽然存在<a href="https://docs.angr.io/advanced-topics/gotchas" rel="nofollow">一些潜在的不准确性</a>，但是可以让你的分析更加可控，</p> 
<p>当找不到某个函数的摘要时：</p> 
<ul><li>如果<code>auto_load_libs</code>的值为<code>True</code>（默认值），那么真正的库函数就会被执行。这可能是你想要的，也可能不是，取决于实际的函数是什么。比如说，一些libc函数十分复杂，难以分析，并且极有可能导致用于确定执行的路径的状态数爆炸。</li><li>如果<code>auto_load_libs</code>是<code>False</code>，那么外部函数就是“未解析”的状态，并且Project对象将会将它们解析为叫做<code>ReturnUnconstrained</code>的通用“stub” SimProdurce。就如它的名字所描述的：每次这个符号被调用，它都会将一个唯一的无约束符号作为返回值。</li><li>如果<code>use_sim_procedures</code>(这是<code>angr.Project</code>的参数，不是<code>cle.loader</code>的参数)是<code>False</code>（默认是True），那么只有外部对象提供的符号才会被SimProcedures替代，并且他们将会被一个<code>ReturnUnconstrained</code>stub替代。</li><li>你可以给<code>angr.Project</code>传以下参数来指定一个不想被SimProcedure替代的符号：<br> <code>exclude_sim_procedures_list</code> 和 <code>exclude_sim_procedures_func</code>。</li><li>查看<code>angr.Project._register_object</code>的源码来获取精确的算法。</li></ul> 
<h5><a id="Hooking_825"></a>钩子(Hooking)</h5> 
<p>angr使用python函数摘要替换库函数代码的机制叫做Hooking，而且你也可以这么做！在执行一次模拟（simulation）时，每一步执行angr都会检查当前地址是否被下了钩子（hooked），并且如果检查到钩子，就会执行钩子函数，而不是那个地址里的二进制码。使用API<code>proj.hook(addr,hook)</code>可以完成hook，这里参数中的<code>hook</code>是一个SimProcedure实例。你可以用<code>.is_hooked</code>，<code>.unhook</code>和<code>.hook_by</code>属性来管理你project中的钩子，这些属性的含义就如字面的意思，这里就不解释了。</p> 
<p>通过把<code>proj.hook(addr)</code>作为一个函数装饰器(function decorator)。，你可以指定你自己的函数作为hook函数。如果你这么做了，你还可以指定一个可选的关键词参数<code>length</code>来决定在你的hook函数执行结束之后，程序跳过多少字节的机器码再继续执行。</p> 
<pre data-index="37" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> stub_func <span class="token operator">=</span> angr<span class="token punctuation">.</span>SIM_PROCEDURES<span class="token punctuation">[</span><span class="token string">'stubs'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ReturnUnconstrained'</span><span class="token punctuation">]</span> <span class="token comment"># this is a CLASS</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>hook<span class="token punctuation">(</span><span class="token number">0x10000</span><span class="token punctuation">,</span> stub_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># hook的实例</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>is_hooked<span class="token punctuation">(</span><span class="token number">0x10000</span><span class="token punctuation">)</span>            <span class="token comment"># 这些函数可以很好的自我解释</span>
<span class="token boolean">True</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>hooked_by<span class="token punctuation">(</span><span class="token number">0x10000</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ReturnUnconstrained<span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>unhook<span class="token punctuation">(</span><span class="token number">0x10000</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> @proj<span class="token punctuation">.</span>hook<span class="token punctuation">(</span><span class="token number">0x20000</span><span class="token punctuation">,</span> length<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">my_hook</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rax <span class="token operator">=</span> <span class="token number">1</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj<span class="token punctuation">.</span>is_hooked<span class="token punctuation">(</span><span class="token number">0x20000</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li></ul></pre> 
<p>此外，你可以使用<code>proj.hook_symbol(name,hook)</code>,提供一个符号名称作为第一个参数，这样第二个参数指定的钩子函数会被下到这个符号被调用的每个地址中。它的一个很重要的用途是用来扩展angr的内建库SimProcedure的行为。因为这些库函数仅仅是一些类，你可以写它们的子类，重写它们的方法，并且把这些子类使用在hook中。</p> 
<h3><a name="t18"></a><a id="Solver_Engine_851"></a>求解引擎(Solver Engine)</h3> 
<p>angr的强大能力不仅因为它是一个模拟器，还因为它能够使用我们称为“符号变量”的东西参与程序的执行。它可以使用一个符号，也就是一个名字，来代替程序执行中的确切数值。然后，在使用符号进行数学运算的过程中，将会产生一棵树(这棵树在编译理论中被称为抽象语法树或AST)。这些AST可以被解释为SMT解析器中的约束条件，就像Z3做的一样。为了回答这样一个问题：“已知经过一系列操作之后得到的输出，输入应该满足怎样的条件？”，在这里，你将会学习如何使用angr来解决这个问题。</p> 
<h4><a name="t19"></a><a id="Working_with_Bitvectors_855"></a>Working with Bitvectors</h4> 
<p>让我们得到一个虚拟的project和state，这样我们就可以和数字玩了。</p> 
<pre data-index="38" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> angr<span class="token punctuation">,</span> monkeyhex
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/bin/true'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> 
<p>位向量(Bitvectors)就是有很多位的序列，可以解释为数学上的有界整数。让我们先生成一些位向量：</p> 
<pre data-index="39" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 64位的位向量，值为1和100</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVV<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one
 <span class="token operator">&lt;</span>BV64 <span class="token number">0x1</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one_hundred <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVV<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one_hundred
 <span class="token operator">&lt;</span>BV64 <span class="token number">0x64</span><span class="token operator">&gt;</span>

<span class="token comment"># 创造一个值为9，27位的位向量</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> weird_nine <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVV<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> weird_nine
<span class="token operator">&lt;</span>BV27 <span class="token number">0x9</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li></ul></pre> 
<p>正如你所看到的，你可以有任何位序列，称它们为位向量。你也可以用它们做数学题：</p> 
<pre data-index="40" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one <span class="token operator">+</span> one_hundred
<span class="token operator">&lt;</span>BV64 <span class="token number">0x65</span><span class="token operator">&gt;</span>

<span class="token comment"># 你可以提供正常的python整数，他们将被强制转换到适当的类型:</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one_hundred <span class="token operator">+</span> <span class="token number">0x100</span>
<span class="token operator">&lt;</span>BV64 <span class="token number">0x164</span><span class="token operator">&gt;</span>

<span class="token comment"># 正常含有算术应用的语义。。？(The semantics of normal wrapping arithmetic apply)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one_hundred <span class="token operator">-</span> one<span class="token operator">*</span><span class="token number">200</span>
<span class="token operator">&lt;</span>BV64 <span class="token number">0xffffffffffffff9c</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre> 
<p>你不能做诸如<code>one+weird_nine</code>这样的操作。对不同长度的位向量做数学运算，将会导致一个类型错误。然而，你可以扩展这个<code>weird_nine</code>，让他具有合适的比特长度：</p> 
<pre data-index="41" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> weird_nine<span class="token punctuation">.</span>zero_extend<span class="token punctuation">(</span><span class="token number">64</span> <span class="token operator">-</span> <span class="token number">27</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>BV64 <span class="token number">0x9</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one <span class="token operator">+</span> weird_nine<span class="token punctuation">.</span>zero_extend<span class="token punctuation">(</span><span class="token number">64</span> <span class="token operator">-</span> <span class="token number">27</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>BV64 <span class="token number">0xa</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<p><code>zero_extend</code>将会用<code>0</code>扩展位向量的高位。为了在扩展时保持二进制补码表示的有符号整数的值，你还可以使用<code>sign_extend</code>来带符号扩展一个位向量。</p> 
<p>现在让我们混入一些符号参与计算：</p> 
<pre data-index="42" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 创建一个名为“x”的位向量符号，长度为64位</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x
<span class="token operator">&lt;</span>BV64 x_9_64<span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> y <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> y
<span class="token operator">&lt;</span>BV64 y_10_64<span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<p><code>x</code>和<code>y</code>现在是“符号变量”，这跟咱们小学学的未知数是一个意思。注意，你提供的符号名（第一个参数）的后面被添加了一个递增的计数值。你可以对这些符号变量做数学计算，想做多少就做多少，但是你不会得到一个数值的结果，而是得到一个AST：</p> 
<pre data-index="43" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">+</span> one
<span class="token operator">&lt;</span>BV64 x_9_64 <span class="token operator">+</span> <span class="token number">0x1</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> one<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
<span class="token operator">&lt;</span>BV64 <span class="token punctuation">(</span>x_9_64 <span class="token operator">+</span> <span class="token number">0x1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">0x2</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">-</span> y
<span class="token operator">&lt;</span>BV64 x_9_64 <span class="token operator">-</span> y_10_64<span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre> 
<p>从技术概念上说<code>x</code>和<code>y</code>甚至<code>one</code>都是AST——即使只有一层。为了理解这一点，让我们学习如何处理AST。</p> 
<p>每一个AST都有<code>.op</code>和一个<code>.args</code>。</p> 
<ul><li> <p><code>.op</code>是一个定义了要执行的运算的属性</p> </li><li> <p><code>.args</code>是参与运算的操作数。</p> </li></ul> 
<p>除非op是字符串"BVV"或"BVS"，所有的args都是AST。AST的终结节点是BVV或BVS。</p> 
<pre data-index="44" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> tree <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> tree
<span class="token operator">&lt;</span>BV64 <span class="token punctuation">(</span>x_9_64 <span class="token operator">+</span> <span class="token number">0x1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>y_10_64 <span class="token operator">+</span> <span class="token number">0x2</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> tree<span class="token punctuation">.</span>op
<span class="token string">'__floordiv__'</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> tree<span class="token punctuation">.</span>args
<span class="token punctuation">(</span><span class="token operator">&lt;</span>BV64 x_9_64 <span class="token operator">+</span> <span class="token number">0x1</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>BV64 y_10_64 <span class="token operator">+</span> <span class="token number">0x2</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> tree<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>op
<span class="token string">'__add__'</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> tree<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>args
<span class="token punctuation">(</span><span class="token operator">&lt;</span>BV64 x_9_64<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>BV64 <span class="token number">0x1</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> tree<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>op
<span class="token string">'BVV'</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> tree<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>args
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li></ul></pre> 
<p>从现在开始，我们将会使用“位向量”这个词来表示一个最上层运算产生一个位向量的AST。通过AST还可以表示其他数据类型，包括浮点数和布尔类型(我们很快会看到)。</p> 
<h4><a name="t20"></a><a id="Symbolic_Constraints_964"></a>符号约束(Symbolic Constraints)</h4> 
<p>在任意两个类型相似的AST之间执行比较操作将生成另一个AST——不是位向量，而是一个符号布尔值。</p> 
<pre data-index="45" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">==</span> <span class="token number">1</span>
<span class="token operator">&lt;</span>Bool x_9_64 <span class="token operator">==</span> <span class="token number">0x1</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">==</span> one
<span class="token operator">&lt;</span>Bool x_9_64 <span class="token operator">==</span> <span class="token number">0x1</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">&gt;</span> <span class="token number">2</span>
<span class="token operator">&lt;</span>Bool x_9_64 <span class="token operator">&gt;</span> <span class="token number">0x2</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">+</span> y <span class="token operator">==</span> one_hundred <span class="token operator">+</span> <span class="token number">5</span>
<span class="token operator">&lt;</span>Bool <span class="token punctuation">(</span>x_9_64 <span class="token operator">+</span> y_10_64<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0x69</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one_hundred <span class="token operator">&gt;</span> <span class="token number">5</span>
<span class="token operator">&lt;</span>Bool <span class="token boolean">True</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> one_hundred <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">5</span>
<span class="token operator">&lt;</span>Bool <span class="token boolean">False</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li></ul></pre> 
<p>从上述例子中你可以看出AST间的比较默认是无符号的。例子中的-5将会被包装为<code>&lt;BV64 0xfffffffffffffffb&gt;</code>，这个数被解释为无符号数之后，显然大于100 。如果你想让比较是带符号的，你可以使用<code>one_hundred.SGT(-5)</code>（SGT意思是“signed greater-than”）。在本章的最后可以找到完整的AST操作列表。</p> 
<p>上面的例子还阐述了一个使用angr的要点——你不应该直接在一个if或while语句中使用两个变量的比较结果作为判断标准，因为这个比较结果可能不是一个确定的真值。即使比较的结果为真，<code>if one &gt; one_hundred</code>将会产生异常。你应该使用<code>solver.is_true</code>和<code>solver.is_false</code>，它们将会测试出一个具体的真假值，而不执行约束求解。</p> 
<pre data-index="46" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> yes <span class="token operator">=</span> one <span class="token operator">==</span> <span class="token number">1</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> no <span class="token operator">=</span> one <span class="token operator">==</span> <span class="token number">2</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> maybe <span class="token operator">=</span> x <span class="token operator">==</span> y
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>is_true<span class="token punctuation">(</span>yes<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>is_false<span class="token punctuation">(</span>yes<span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>is_true<span class="token punctuation">(</span>no<span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>is_false<span class="token punctuation">(</span>no<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>is_true<span class="token punctuation">(</span>maybe<span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>is_false<span class="token punctuation">(</span>maybe<span class="token punctuation">)</span>
<span class="token boolean">False</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li></ul></pre> 
<h4><a name="t21"></a><a id="Constraint_Solving_1005"></a>约束求解(Constraint Solving)</h4> 
<p>你可以用加入一个约束条件到一个state中的方法（<code>state.solver.add</code>），将每一个符号化的布尔值作为一个关于符号变量合法性的断言。之后可以通过使用<code>state.solver.eval(symbol)</code>对各个断言进行评测来求出一个合法的符号值（若有多个合法值，返回其中的一个）。</p> 
<pre data-index="47" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x <span class="token operator">&gt;</span> y<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span>y <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">&gt;</span> x<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token number">4</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre> 
<p>通过添加这些约束到一个state中，我们已经迫使约束求解器考虑我们添加的断言，求解器返回的值必须满足这些断言。如果你运行上面的例子，你可能会得到x的不同值，但是这个值将必然大于3(因为y &gt; 2且x &gt;= y 且 x &lt;= 10)。此外，如果你接着用<code>state.solver.eval(y)</code>求解y，你将会得到一个被之前求解出的x的值限制的y值。如果在两个查询之间不添加任何约束，那么结果将是一致的。</p> 
<p>从这里，很容易看到如何完成我们在本章开始时提出的任务——查找产生给定输出的输入。</p> 
<pre data-index="48" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 获得一个没有约束的新状态</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">input</span> <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> operation <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">input</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">input</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> output <span class="token operator">=</span> <span class="token number">200</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span>operation <span class="token operator">==</span> output<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>
<span class="token number">0x3333333333333381</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre> 
<p>再次提醒，这样的求解方式只适用于位向量的语义下(也就是之前提到的AST)。如果我们在整数域上做上面的操作，将会是无解的。</p> 
<p>如果我们将两个互相矛盾或相反的约束加入一个<code>state.solver</code>中，比如没有一个值能够满足所有约束，那么这个state就变成了<code>unsatisfiable</code>，或者unsat，并且对这样的state求解会导致异常。你可以用<code>state.satisfiable()</code>检查一个state是否可解，接着上面的例子：</p> 
<pre data-index="49" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token builtin">input</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>satisfiable<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> 
<p>你还可以加入更复杂的表达式，而不仅是包含一个符号变量的表达式：</p> 
<pre data-index="50" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 新状态</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x <span class="token operator">-</span> y <span class="token operator">&gt;=</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span>y <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span>
<span class="token number">6</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre> 
<p>这里我们可以看到，<code>eval</code>是一个通用的方法，它在考虑整个state(的约束)的情况下，将任意位向量转换为python基本类型。这也是为什么我们使用<code>eval</code>来将具体的位向量转换为python的int类型的原因。</p> 
<p>还需要注意的是符号变量x和y可以在新的state中被使用，尽管它在旧的state中被创建。符号变量不和state绑定，它们是自由存在的。</p> 
<h4><a name="t22"></a><a id="Floating_point_numbers_1061"></a>浮点数(Floating point numbers)</h4> 
<p>z3(一个约束求解的python库)已经提供了对IEEE754浮点数标准的支持，并且因此angr也能够使用它们（因为angr集成了z3）。创建浮点数向量和创建一个向量主要的不同在于，浮点数向量的第二个参数不是位向量宽度，而是一个<code>sort</code>。你可以使用<code>FPV</code>和<code>FPS</code>来创建一个浮点值和符号。</p> 
<pre data-index="51" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 新状态</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>FPV<span class="token punctuation">(</span><span class="token number">3.2</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>fp<span class="token punctuation">.</span>FSORT_DOUBLE<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a
<span class="token operator">&lt;</span>FP64 FPV<span class="token punctuation">(</span><span class="token number">3.2</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>FPS<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>fp<span class="token punctuation">.</span>FSORT_DOUBLE<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b
<span class="token operator">&lt;</span>FP64 FPS<span class="token punctuation">(</span><span class="token string">'FP_b_0_64'</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token operator">+</span> b
<span class="token operator">&lt;</span>FP64 fpAdd<span class="token punctuation">(</span><span class="token string">'RNE'</span><span class="token punctuation">,</span> FPV<span class="token punctuation">(</span><span class="token number">3.2</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token punctuation">,</span> FPS<span class="token punctuation">(</span><span class="token string">'FP_b_0_64'</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token operator">+</span> <span class="token number">4.4</span>
<span class="token operator">&lt;</span>FP64 FPV<span class="token punctuation">(</span><span class="token number">7.6000000000000005</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">0</span>
<span class="token operator">&lt;</span>Bool fpLT<span class="token punctuation">(</span>fpAdd<span class="token punctuation">(</span><span class="token string">'RNE'</span><span class="token punctuation">,</span> FPS<span class="token punctuation">(</span><span class="token string">'FP_b_0_64'</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token punctuation">,</span> FPV<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FPV<span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li></ul></pre> 
<p>所以这里有一些需要解释的地方——首先对于浮点数向量的显示并不是很好，但是抛开这个不谈，大多数的浮点数操作实际上都有第三个参数，它在你使用二进制运算符时被隐式地添加——这个参数是舍入模式。IEEE754定义了多个舍入模式(向最近的数舍入，向0舍入，舍入到正数等等)，所以z3必须支持它们。如果你想要对某个操作（比如<code>solver.fpAdd</code>）指定舍入模式，你就得在使用该操作时显示声明一个舍入模式(<code>solver.fp.RM_*</code>中的一个)作为参数。</p> 
<p>浮点数符号的约束和求解工作按照和整型符号相同的方式工作，但是使用<code>eval</code>将会返回一个浮点值：</p> 
<pre data-index="52" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>add<span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">2.4999999999999996</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<p>这很好，但是有时候我们需要能够直接和浮点数的位向量形式直接交互。你可以使用<code>raw_to_bv</code>和<code>raw_to_fp</code>将位向量解析为浮点数，反之亦可：</p> 
<pre data-index="53" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a<span class="token punctuation">.</span>raw_to_bv<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>BV64 <span class="token number">0x400999999999999a</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b<span class="token punctuation">.</span>raw_to_bv<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>BV64 fpToIEEEBV<span class="token punctuation">(</span>FPS<span class="token punctuation">(</span><span class="token string">'FP_b_0_64'</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVV<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">.</span>raw_to_fp<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>FP64 FPV<span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVS<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">.</span>raw_to_fp<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>FP64 fpToFP<span class="token punctuation">(</span>x_1_64<span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre> 
<p>这些转换保留了位模式，就像把一个int指针转为浮点指针(或相反)一样。然而，如果你想尽量不丢失精度，当你想将一个浮点数转为int（或反过来）你可以使用另一组方法：<code>val_to_fp</code>和<code>val_to_bv</code>。由于浮点数的浮点特性，这些方法必须将目标值的位宽或种类作为参数：</p> 
<pre data-index="54" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a
<span class="token operator">&lt;</span>FP64 FPV<span class="token punctuation">(</span><span class="token number">3.2</span><span class="token punctuation">,</span> DOUBLE<span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a<span class="token punctuation">.</span>val_to_bv<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>BV12 <span class="token number">0x3</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a<span class="token punctuation">.</span>val_to_bv<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val_to_fp<span class="token punctuation">(</span>state<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>fp<span class="token punctuation">.</span>FSORT_FLOAT<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>FP32 FPV<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> FLOAT<span class="token punctuation">)</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li></ul></pre> 
<p>这些方法还可以加一个<code>signed</code>参数，指定源或目的位向量是否是有符号的。</p> 
<h4><a name="t23"></a><a id="More_Solving_Methods_1124"></a>更多的解决方法(More Solving Methods)</h4> 
<p><code>eval</code>将会给出一个符合约束条件的可行解，但是如果你想要多个可行解时怎么办呢？你如何确定这个解是不是唯一的？解析器为你提供了一些通用的解决方案：</p> 
<ul><li><code>solver.eval(expression)</code> 将会解出一个可行解</li><li><code>solver.eval_one(expression)</code>将会给出一个表达式的可行解，若有多个可行解，则抛出异常。</li><li><code>solver.eval_upto(expression, n)</code>将会给出最多n个可行解，如果不足n个就给出所有的可行解。</li><li><code>solver.eval_exact(expression, n)</code>将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。</li><li><code>solver.min(expression)</code>将会给出最小可行解</li><li><code>solver.max(expression)</code>将会给出最大可行解</li></ul> 
<p>另外，上述这些方法都可以接收如下关键字参数：</p> 
<ul><li><code>extra_constraints</code>可以传入元组形式的约束条件。这些约束将会在本次求解中被考虑，但是不加入state中。</li><li><code>cast_to</code>可以接收一个参数来指定把结果映射到哪种数据类型。目前这个参数只能是<code>str</code>，它将会以字符串形式展示返回的结果。例如：<code>state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=bytes)</code> will return <code>b'ABCD'</code>.</li></ul> 
<h4><a name="t24"></a><a id="_1140"></a>小结</h4> 
<p>内容真多！读完本章之后，你应该能够创建和操作位向量、布尔值和浮点数来形成操作树，之后用附加在state上的约束求解器，根据约束条件集，求得一个（或多个）可行解。希望你读完本章能够体会到用AST来表示运算以及约束求解器的强大。</p> 
<p>在<a href="https://docs.angr.io/appendix/ops" rel="nofollow">附录</a>中，你能够找到可以对AST进行的所有操作。</p> 
<h3><a name="t25"></a><a id="Program_State_1146"></a>项目状态(Program State)</h3> 
<p>到目前为止，我们只在最基础的层次上使用angr模拟的程序状态（<code>SimState</code>对象）来展示angr操作的核心概念。在这里，你将会学习更多的state对象的结构，并且学习多样、有用的方式和它交互。</p> 
<h4><a name="t26"></a><a id="_1150"></a>回顾：读、写内存和寄存器</h4> 
<p>如果你按照顺序阅读本文档（至少在文档的第一部分你应该这么做），那么你应该已经看到了访问内存和寄存器的基本方法。<code>state.regs</code>对象通过以各个寄存器名命名的属性，提供对各寄存器的读写权限；<code>state.mem</code>提供了对内存的读写权限，你可以通过下标索引符号访问各个内存，可以使用内存对象的属性来指定内存应该被作为什么类型的数据处理。</p> 
<p>另外，现在你应该知道什么是AST，并且理解了任何位向量形式的AST都可以被存储在内存或寄存器中。</p> 
<p>下面是一些关于从state是拷贝和执行数据操作的快捷例子：</p> 
<pre data-index="55" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> angr<span class="token punctuation">,</span> claripy
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/bin/true'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 将rsp赋值给rbp</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rbp <span class="token operator">=</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rsp

<span class="token comment"># 将rdx赋值给内存地址0x1000</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>mem<span class="token punctuation">[</span><span class="token number">0x1000</span><span class="token punctuation">]</span><span class="token punctuation">.</span>uint64_t <span class="token operator">=</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rdx

<span class="token comment"># 废弃rbp</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rbp <span class="token operator">=</span> state<span class="token punctuation">.</span>mem<span class="token punctuation">[</span>state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rbp<span class="token punctuation">]</span><span class="token punctuation">.</span>uint64_t<span class="token punctuation">.</span>resolved

<span class="token comment"># add rax, qword ptr [rsp + 8]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rax <span class="token operator">+=</span> state<span class="token punctuation">.</span>mem<span class="token punctuation">[</span>state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rsp <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">.</span>uint64_t<span class="token punctuation">.</span>resolved
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li></ul></pre> 
<h4><a name="t27"></a><a id="Basic_Execution_1176"></a>基础执行(Basic Execution)</h4> 
<p>在前面的文档中，我们展示了如何使用Simulatin Manager（SM）来做一些基础执行。在下一章我们将会展示SM的全部能力，但是现在我们使用一个简单得多的接口<code>state.step()</code>来展示符号执行是如何工作的。这个方法会执行一步符号执行操作，并返回一个<code>Simsuccessors</code>。和正常的模拟不同，符号执行可以产生几种可以按照多种方式分类的后继状态。现在我们只关心这个对象的<code>.successors</code>属性，它是包含程序执行一步之后的所有“正常”后继状态的列表。</p> 
<p>为什么使用列表而不是单个继承状态？angr的符号执行过程是仅仅取出编译在程序中的要执行的独立的指令，并且执行它来改变<code>Simstate</code>。当一行诸如<code>if(x &gt; 4)</code>的语句被执行时，如果x是个符号（而没有具体数值），那么会发生什么呢？在angr底层的某个地方，比较<code>x &gt; 4</code>将会被执行，且结果将会是<code>&lt;Bool x_32_1 &gt; 4&gt;</code></p> 
<p>这很好，那么接下来的问题是，我们是要“true”分支，还是要“false”分支呢？答案是，我们两个都要！我们产生两个完全分开的状态——一个用于模拟条件为真，另一个用于模拟条件为假。在第一个状态中，我们添加<code>x &gt; 4</code>为约束条件，而在第二个状态中，我们添加<code>!(x &gt; 4)</code>为约束条件。用这样的方式，就能够确保不论何时我们使用这两个后继状态之一，状态中的约束条件都能够保证约束求解器解出的任何结果都是一个使得程序按照该状态指向的程序路径执行的合法输入。</p> 
<p>为了演示这一点，让我们使用一个<a href="https://github.com/angr/angr-doc/tree/842715e048f9b26433739faed75855b7faee5833/examples/fauxware/fauxware/README.md">伪造的固件镜像</a> 作为例子。如果你看过这个程序的<a href="https://github.com/angr/angr-doc/tree/842715e048f9b26433739faed75855b7faee5833/examples/fauxware/fauxware.c">源码</a>，你将会看到它的授权机制有一个后门；任意用户名，都能通过验证，只要密码是“SOSNEAKY”。此外，用户输入的第一层比较判断是后门代码的判断，所以如果我们一直执行，直到我们得到不止一个继承状态，它们中的一个将会包含使得用户输入通过后门判断的限制条件。下面是代码实现：</p> 
<pre data-index="56" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'examples/fauxware/fauxware'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span>stdin<span class="token operator">=</span>angr<span class="token punctuation">.</span>SimFile<span class="token punctuation">)</span>  <span class="token comment"># 现在先忽略这个问题——为了方便学习，我们正在禁用一个更复杂的默认设置</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     succ <span class="token operator">=</span> state<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>succ<span class="token punctuation">.</span>successors<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">break</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     state <span class="token operator">=</span> succ<span class="token punctuation">.</span>successors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state1<span class="token punctuation">,</span> state2 <span class="token operator">=</span> succ<span class="token punctuation">.</span>successors
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state1
<span class="token operator">&lt;</span>SimState @ <span class="token number">0x400629</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state2
<span class="token operator">&lt;</span>SimState @ <span class="token number">0x400699</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li></ul></pre> 
<p>不要直接看这些状态的约束——我们刚刚执行过的代码中包括库函数<code>strcmp</code>的执行，用符号化模拟这个函数很复杂，并且导致了结果中的约束条件也很复杂。</p> 
<p>我们模拟的程序从标准输入中读入数据，angr默认把标准输入看做一个无限符号数据流。为了得到满足约束的可能输入值，我们需要获取标准输入的实际内容的引用。我们将会在本章的后半部分介绍我们的文件和输入系统是如何工作的，但是现在只使用<code>state.posix.stdin.load(0, state.posix.stdin.size)</code>来获取从stdin读取的所有内容的位向量。</p> 
<pre data-index="57" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> input_data <span class="token operator">=</span> state1<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>size<span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state1<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>input_data<span class="token punctuation">,</span> cast_to<span class="token operator">=</span><span class="token builtin">bytes</span><span class="token punctuation">)</span>
<span class="token string">b'\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00\x00\x00'</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state2<span class="token punctuation">.</span>solver<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>input_data<span class="token punctuation">,</span> cast_to<span class="token operator">=</span><span class="token builtin">bytes</span><span class="token punctuation">)</span>
<span class="token string">b'\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00\x00\x00'</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<p>正如你看到的，为了进入<code>state1</code>指向的分支，你必须提供一个密码“SOSNEAKY”给后门代码。为了进入<code>state2</code>指向的分支，你必须给出不是“SOSNEAKY”的输入。z3已经从数以万计的符合条件的字符串中提取了一个符合条件的字符串给我们。</p> 
<p>Fauxware是使用angr第一次成功符号执行的程序（2013年）。通过使用angr找到这个后门的同时，你也在参与一项伟大的传统：理解如何使用符号执行从二进制文件中提取有意义的信息。</p> 
<h4><a name="t28"></a><a id="State_Presets_1220"></a>状态预置(State Presets)</h4> 
<p>到目前为止，每当我们想要使用state，我们都用这样一个语句创建：<code>project.factory.entry_state()</code>。这只是factory提供的多个构造函数中的一个：</p> 
<ul><li><code>.blank_state()</code> 构造一个“空状态”，它的大多数数据都是未初始化的。当使用未初始化的的数据时，一个不受约束的符号值将会被返回。</li><li><code>.entry_state</code>构造一个已经准备好从函数入口点执行的状态。</li><li><code>.full_init_state()</code>构造一个已经执行过所有与需要执行的初始化函数，并准备从函数入口点执行的状态。比如，共享库构造函数（constructor）或预初始化器。当这些执行完之后，程序将会跳到入口点。</li><li><code>.call_state()</code>构造一个已经准备好执行某个函数的状态。</li></ul> 
<p>你可以通过对这些构造函数传参来构建自定义状态：</p> 
<ul><li>所有这些构造函数都可以获取一个<code>addr</code>作为参数来从一个指定地点开始。</li><li>如果你在一个可以获取命令行参数或环境参数的环境下运行，你可以传入一个<code>args</code>列表和一个存储环境参数的<code>env</code>字典给<code>entry_steate()</code>或<code>full_init_state</code>。列表和字典里的值可以是字符串或位向量，并且被序列化存入state中，作为模拟执行的命令行参数和环境参数。默认的<code>args</code>是一个空列表，所以如果你要分析一个至少需要<code>args[0]</code>的程序，那么你应该提供它。</li></ul> 
<blockquote> 
 <p>注：一般.exe和.elf文件的args[0]都是程序名。</p> 
</blockquote> 
<ul><li> <p>如果你希望<code>argc</code>被符号化，你可以传入一个位向量<code>argc</code>给<code>entry_state</code>和<code>full_init_state</code>构造函数。但是要小心：如果你这么做了，那么你还得在结果状态中添加一条约束，即argc的值不能大于你传入<code>args</code>中的参数的个数。</p> </li><li> <p>为了使用<code>call_state</code>，你应该用<code>call_state(addr,arg1,arg2,arg3...)</code>这样的方式，其中<code>addr</code>是要调用的函数的地址，<code>argN</code>是要调用的函数的第N个参数：可以是python整型、字符串、或者数组、或者位向量。如果你想申请一块内存并把指向内存的指针传入一个对象，那么你应该将指针用<code>PointerWrapper</code>包装一下，例如，<code>angr.PointerWrapper("point to me")</code>。这个API的调用结果可能有点不可预测，我们还在努力改进它。</p> </li><li> <p>为了指定使用<code>call_state</code>来调用函数时的调用约定，你可以传入<a href="http://angr.io/api-doc/angr.html#module-angr.calling_conventions" rel="nofollow">SimCCInstance</a> 作为<code>cc</code>参数。</p> <p>我们正努力选择一个比较好的默认参数，但是在特定情况下需要你来告诉angr使用哪种调用约定。</p> </li></ul> 
<p>还有更多能用于上述所有构造函数的选项，在本章的末尾会列出来。</p> 
<h4><a name="t29"></a><a id="_1246"></a>低级内存接口</h4> 
<p><code>state.mem</code>接口对于从内存中以指定类型取出数据是很方便的，但是如果你想手动在某块内存中做存取操作，这个接口就显得很笨拙了。实际上，<code>state.mem</code>只是一堆用于正确访问下层内存存储的逻辑，而内存存储是一块填充着位向量数据的平坦地址空间：<code>state.memory</code>。你可以直接对<code>state.memory</code>使用<code>.load(addr,size)</code>和<code>store(addr,val)</code>方法：</p> 
<pre data-index="58" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>blank_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>store<span class="token punctuation">(</span><span class="token number">0x4000</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>solver<span class="token punctuation">.</span>BVV<span class="token punctuation">(</span><span class="token number">0x0123456789abcdef0123456789abcdef</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token number">0x4004</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment"># load大小以字节为单位,取6字节</span>
<span class="token operator">&lt;</span>BV48 <span class="token number">0x89abcdef0123</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<p>可以看到，数据按照“大端”字节序存取，因为<code>state.memory</code>的主要目的是存取没有附加语义的大块数据。然而，如果你想对存取的数据执行字节交换，那么你可以传入关键字参数<code>endness</code>——如果你指定小端顺序，字节交换就会发生。字节序类型必须是在<code>archinfo</code>包中angr用于存储CPU架构陈述性信息的枚举变量<code>Endness</code>的成员之一。另外，被分析的程序的字节序类型可以在<code>arch.memory_endness</code>中找到——比如<code>state.arch.memory_endness</code>。</p> 
<pre data-index="59" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> archinfo
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>memory<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token number">0x4000</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> endness<span class="token operator">=</span>archinfo<span class="token punctuation">.</span>Endness<span class="token punctuation">.</span>LE<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>BV32 <span class="token number">0x67453201</span><span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> 
<p>寄存器也有低级接口，<code>state.registers</code>:它和<code>state.memory</code>使用完全相同的API，但是要解释它的行为需要<a href="https://docs.angr.io/advanced-topics/ir" rel="nofollow">深入</a>angr用于无缝操作各个CPU架构的抽象结构。比较简短的解释是它仅仅是一个寄存器文件，其中包含着<a href="https://github.com/angr/archinfo">archinfo</a>中定义的寄存器和偏移的映射。</p> 
<h4><a name="t30"></a><a id="_1267"></a>状态选项</h4> 
<p>你可以对angr内部做许多调整，这些调整在某些情况下会优化程序执行，而有些情况下则正相反。这些调整可以通过状态选项控制。</p> 
<p>对于每个SimState对象，都有一个<code>state,option</code>集合，里面存储着所有所有已经开启的状态选项。每个选项（只是一个字符串）都以某种分钟的方式控制这angr执行引擎的行为。所有可选的选项，以及它们在不同类型的状态下的默认值都可以在<a href="https://docs.angr.io/appendix/options" rel="nofollow">这个附录</a>中找到。你可以通过<code>angr.options</code>获取一个独立的(状态)选项来添加到某个state中。这些独立的(状态)选项都被大写字母命名，当然你有可能想要使用多个选项对象的组合，这些组合用小写字母命名。</p> 
<p>当你通过任何一个构造函数构造一个SimState时，你可以传入关键字参数<code>add_options</code>和<code>remove_options</code>,它们需要以选项集合的形式传入来修改默认的初始选项集合。</p> 
<pre data-index="60" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 示例:启用延迟解决，这是一个导致尽可能不频繁地检查状态可满足性的选项。</span>
<span class="token comment"># 对设置的更改将传播到这一行之后从此状态创建的所有后续状态。</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>options<span class="token punctuation">.</span>add<span class="token punctuation">(</span>angr<span class="token punctuation">.</span>options<span class="token punctuation">.</span>LAZY_SOLVES<span class="token punctuation">)</span>

<span class="token comment"># 创建一个启用延迟解决方案的新状态</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span>add_options<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>angr<span class="token punctuation">.</span>options<span class="token punctuation">.</span>LAZY_SOLVES<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment"># 在不启用简化选项的情况下创建新状态</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span>remove_options<span class="token operator">=</span>angr<span class="token punctuation">.</span>options<span class="token punctuation">.</span>simplification<span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre> 
<p>第一行启动了“lazy solves”选项，这个选项将会导致对约束条件是否满足的检测尽可能慢地执行；这个改变将会对从这一行代码之后由这个状态产生的所有衍生状态有效。</p> 
<p>第二行代码在初始化状态的时候加入了“lazy solves”选项。</p> 
<p>第三行代码创建了一个没有simplification选项的状态。</p> 
<h4><a name="t31"></a><a id="State_Plugins_1293"></a>状态插件(State Plugins)</h4> 
<p>除了刚刚讨论过的选项集，所有存储在SimState中的东西实际上都存储在附加在state上的“插件”中。到目前为止我们讨论的几乎所有state的属性都是一个插件——<code>memory</code>、<code>registers</code>、<code>mem</code>、<code>regs</code>、<code>solver</code>等等。这种设计带来了代码的模块化和能够便捷地为模拟状态的其他方面<a href="https://docs.angr.io/extending-angr/state_plugins" rel="nofollow">实现新的数据存储</a>，或者提供插件的替代实现能力。</p> 
<p>比如说，通常<code>memory</code>插件模拟一个平坦地址空间，但是在分析中可以选择开启“抽象内存”插件来支持<code>state.memory</code>，“抽象内存”使用新的数据类型表示地址，以模拟浮动的独立内存空间映射。反过来，插件可以减少代码的复杂性：<code>state.memory</code>和<code>state.registers</code>实际上是同一个插件的不同实例，因为寄存器也是用一块地址空间模拟的。</p> 
<h5><a id="The_globals_plugin_1299"></a>全局插件(The globals plugin)</h5> 
<p><code>state.global</code>是一个很简单的插件：它实现了标准python dict接口，允许你在state中存储任意数据。</p> 
<h5><a id="history_1303"></a>history插件</h5> 
<p><code>state.history</code>是一个很重要的插件，它记录一个状态的执行路径。实际上它是一个链表，每一个节点代表一次执行——你可以使用<code>state.history.parent.parent</code>等等来回溯这个链表。</p> 
<p>为了更方便地操作这个结构，history插件还提供了多个高效的迭代器来覆盖某些值的历史，这些值被存储为<code>history.recent_NAME</code>且它们的迭代器就是<code>history.NAME</code>。例如： <code>for addr in state.history.bbl_addrs: print hex(addr)</code> 将会打印出这个二进制的基础块地址跟踪信息。然而<code>state.history.recent_bbl_addrs</code>是最近执行的基础块地址的列表，<code>state.history.parent.recent_bbl_addrs</code>是上一个state最近执行的基础块地址的列表，等等。如果你需要快速获取这些值的平面列表，你可以使用<code>.hardcopy</code>,比如，<code>state.history.bbl_addrs.hardcopy</code>。但是请记住，基于索引的访问是在迭代器上实现的。</p> 
<p>下面是一些存储在history插件中的值的简要列表：</p> 
<ul><li><code>history.descriptions</code>是描述state上每轮执行的状态的字符串列表。</li><li><code>history.bbl_addrs</code>是state已经执行过的基本块的地址列表。这里可能每轮执行一个以上，并且不是所有的地址都有对应的二进制代码——一些地址可能已经被SimProcedure hook了</li><li><code>history.jumpkinds</code>是状态历史中每个控制流转换的处置列表，就像VEX枚举字符。</li><li><code>history.guards</code>是一个state当前所走路径需要满足的条件列表。</li><li><code>history.events</code>是一些执行过程中发生的“有趣的事情”的列表，比如说符号跳转条件、程序弹出一个消息框或者程序执行到退出代码退出。</li><li><code>history.action</code>通常是空的，但如果你加入<code>angr.options.refs</code>选项到state中，它将填充程序对所有内存、寄存器、临时值访问的日志。</li></ul> 
<h5><a id="_1318"></a>调用栈插件</h5> 
<p>angr会跟踪所模拟的程序的调用栈。在每条call指令处，一个栈帧会被加载到被跟踪的调用栈的栈顶，并且当栈指针低于最上层被调用的栈帧时，一个栈帧就被弹出。这使得angr能够稳健地存储当前模拟的函数的局部数据。</p> 
<p>和history一样，调用栈仍然是链表结构的，但是没有提供调用栈的专门的迭代器——取而代之，你可以直接使用<code>state.callstack</code>来获取每一个没有被弹出的栈帧，顺序是最近调用优先。如果你想要最高的栈帧，那就是<code>stata.callstack</code>。</p> 
<ul><li><code>callstack.func_addr</code>是当前正在执行的函数地址。</li><li><code>callstack.call_site_addr</code>是调用当前函数的基本块地址。</li><li><code>callstack.stack_ptr</code>是从当前函数开始时的栈顶指针。（即ebp）</li><li><code>callstack.ret_addr</code>是当前函数将要返回的地址。</li></ul> 
<h4><a name="t32"></a><a id="_1329"></a>拷贝和合并</h4> 
<p>state支持快速拷贝，使你可以尝试不同的可能性：</p> 
<pre data-index="61" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'/bin/true'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>blank_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s1 <span class="token operator">=</span> s<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s2 <span class="token operator">=</span> s<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s1<span class="token punctuation">.</span>mem<span class="token punctuation">[</span><span class="token number">0x1000</span><span class="token punctuation">]</span><span class="token punctuation">.</span>uint32_t <span class="token operator">=</span> <span class="token number">0x41414141</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s2<span class="token punctuation">.</span>mem<span class="token punctuation">[</span><span class="token number">0x1000</span><span class="token punctuation">]</span><span class="token punctuation">.</span>uint32_t <span class="token operator">=</span> <span class="token number">0x42424242</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<p>state还可以被合并到一起：</p> 
<pre data-index="62" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># merge将返回一个元组。第一个元素是合并的状态</span>
<span class="token comment"># 第二个元素是描述状态标志的符号变量</span>
<span class="token comment"># 第三个元素是一个布尔值，描述是否进行了合并</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>s_merged<span class="token punctuation">,</span> m<span class="token punctuation">,</span> anything_merged<span class="token punctuation">)</span> <span class="token operator">=</span> s1<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>s2<span class="token punctuation">)</span>

<span class="token comment"># 现在这个表达式可以解析为“AAAA”*或“BBBB”</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> aaaa_or_bbbb <span class="token operator">=</span> s_merged<span class="token punctuation">.</span>mem<span class="token punctuation">[</span><span class="token number">0x1000</span><span class="token punctuation">]</span><span class="token punctuation">.</span>uint32_t
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<h3><a name="t33"></a><a id="Simulation_Managers_1355"></a>模拟管理器(Simulation Managers)</h3> 
<p>SM（Simulation Managers）是angr中最重要的控制接口，它使你能够同时控制一组状态(state)的符号执行，应用搜索策略来探索程序的状态空间。现在我们就来学习如何使用它。</p> 
<p>SM使你可以顺畅地控制多个状态。在SM中，状态都被组织在“stash”里，你可以对它们做执行一步、过滤、合并以及随意移动等操作。比如说，这允许你使两个不同的“stash”中的状态以不同的速度执行，然后再将它们合并。对大多数操作而言，默认的stash是<code>active</code>stash，当你初始化一个新的SM时，你的状态就放在那里面。</p> 
<h5><a id="_1361"></a>单步执行</h5> 
<p>SM的最基本能力就是让一个stash中的所有状态都执行一个基本块。使用<code>.step()</code>可以做到这一点：</p> 
<pre data-index="63" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> angr
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'examples/fauxware/fauxware'</span><span class="token punctuation">,</span> auto_load_libs<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> state <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simgr<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>active
<span class="token punctuation">[</span><span class="token operator">&lt;</span>SimState @ <span class="token number">0x400580</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>active
<span class="token punctuation">[</span><span class="token operator">&lt;</span>SimState @ <span class="token number">0x400540</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre> 
<p>当然，stash模式的真正强大之处在于，当一个状态执行到一个符号分支条件时，这个分支后的两个继承状态都会出现在stash中，而且你可以使它们同步地单步执行，如果你想仔细控制程序执行而且你只想执行到没有状态可以继续执行，你可以直接使用<code>.run()</code>方法：</p> 
<pre data-index="64" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 单步执行直到第一个符号分支</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>simgr<span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    simgr<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr
<span class="token operator">&lt;</span>SimulationManager <span class="token keyword">with</span> <span class="token number">2</span> active<span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>active
<span class="token punctuation">[</span><span class="token operator">&lt;</span>SimState @ <span class="token number">0x400692</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>SimState @ <span class="token number">0x400699</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>

<span class="token comment"># 单步执行，直到一切结束</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr
<span class="token operator">&lt;</span>SimulationManager <span class="token keyword">with</span> <span class="token number">3</span> deadended<span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li></ul></pre> 
<p>现在我们得到了3个“deadend”状态!如果一个状态在执行后不能够产生任何后继状态，例如它执行了一个<code>exit</code>的系统调用，那么这个状态就会被放入<code>deadend</code>stash。</p> 
<h5><a id="Stash__1398"></a>Stash 管理</h5> 
<p>让我们看看如何使用Stash。</p> 
<p>使用<code>.move()</code>将状态在不同stash间移动，这个方法接收参数<code>from_stash</code>，<code>to_stash</code>和<code>filter_func</code>（这个参数是可选的，默认将stash中的所有状态都移动）。例如，我们可以将输出带有特定字符串的状态都移动到指定的stash中：</p> 
<pre data-index="65" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>move<span class="token punctuation">(</span>from_stash<span class="token operator">=</span><span class="token string">'deadended'</span><span class="token punctuation">,</span> to_stash<span class="token operator">=</span><span class="token string">'authenticated'</span><span class="token punctuation">,</span> filter_func<span class="token operator">=</span><span class="token keyword">lambda</span> s<span class="token punctuation">:</span> <span class="token string">b'Welcome'</span> <span class="token keyword">in</span> s<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr
<span class="token operator">&lt;</span>SimulationManager <span class="token keyword">with</span> <span class="token number">2</span> authenticated<span class="token punctuation">,</span> <span class="token number">1</span> deadended<span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre> 
<p>我们可以通过要求将状态移入某个新的stash的方法来创建一个新的stash。在这个stash中的所有状态的标准输出中都有一个“Welcome”字符串，在目前这是一个很好的状态分类指标。</p> 
<p>每一个stash都是一个列表，你可以通过索引或者迭代器的方式访问到每一个独立的状态，但是也有一些替代的方法来访问每个状态。如果你用“one_stash名”的方式访问stash，那么你会获得这个stash中的第一个状态；如果你用“mp_stash名”的方式访问stash，那么你将会得到<a href="https://github.com/zardus/mulpyplexer">mulpyplexed</a>版本的stash：</p> 
<pre data-index="66" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> simgr<span class="token punctuation">.</span>deadended <span class="token operator">+</span> simgr<span class="token punctuation">.</span>authenticated<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">0x1000030</span>
<span class="token number">0x1000078</span>
<span class="token number">0x1000078</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>one_deadended
<span class="token operator">&lt;</span>SimState @ <span class="token number">0x1000030</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>mp_authenticated
MP<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>SimState @ <span class="token number">0x1000078</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>SimState @ <span class="token number">0x1000078</span><span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>mp_authenticated<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
MP<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00'</span><span class="token punctuation">,</span>
    <span class="token string">'\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80@\x80@\x00'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li></ul></pre> 
<p>当然，<code>step</code>，<code>run</code>，以及任何其它的可以在一个stash的路径上操作的方法，都可以指定一个stash参数，指定对哪个stash做操作。</p> 
<p>SM还提供了很多有趣的工具来帮助你管理你的stash。我们现在不会深入每一个工具的使用，但是你可以查看API文档。（文档链接未完成）</p> 
<h4><a name="t34"></a><a id="stash_1434"></a>stash类型</h4> 
<p>你可以使用任何你喜欢的stash，但是有一些被用于分类特殊状态的stash，它们是：</p> 
<div class="table-box"><table><thead><tr><th>Stash</th><th>描述</th></tr></thead><tbody><tr><td>active</td><td>这个stash中的状态会被默认执行，除非执行前指定了特定要执行的stash</td></tr><tr><td>deadended</td><td>当一个状态因为某些原因不能继续执行时，它就进入"deadend"stash。这些原因包括没有合法指令可以执行、所有子状态（的约束条件）都不可满足、或者一个非法的PC指针。</td></tr><tr><td>pruned</td><td>当使用<code>LAZY_SOLVES</code>时，不到万不得已时不会检测state是否可满足。当在<code>LAZY_SOLVES</code>模式下一个状态被发现不可满足时，这个状态的父状态就会被检查，以找出状态历史中最开始的那个不可满足的状态，这个状态的所有子孙状态都是不可满足的（因为一个不可满足的状态不会变为可满足的状态），因此这些状态都需要被剪切掉，并且放入“pruned”stash中。</td></tr><tr><td>unconstrained</td><td>如果<code>save_unconstrained</code>选项被提供给SM的构造函数，那么被认为"不受约束"的状态（比如指令指针被用户输入或者其他符号来源控制的状态）就被放在这个stash中。</td></tr><tr><td>unsat</td><td>如果<code>save_unsat</code>选项被提供给SM的构造函数，那么被认定不可满足的状态（比如某个状态有两个互相矛盾的约束条件）会被放在这里。</td></tr></tbody></table></div> 
<p>There is another list of states that is not a stash: <code>errored</code>. If, during execution, an error is raised, then the state will be wrapped in an <code>ErrorRecord</code> object, which contains the state and the error it raised, and then the record will be inserted into <code>errored</code>. You can get at the state as it was at the beginning of the execution tick that caused the error with <code>record.state</code>, you can see the error that was raised with <code>record.error</code>, and you can launch a debug shell at the site of the error with <code>record.debug()</code>. This is an invaluable debugging tool!</p> 
<h5><a id="Simple_Exploration_1448"></a>简单探索(Simple Exploration)</h5> 
<p>符号执行最普遍的操作是找到能够到达某个地址的状态，同时丢弃其他不能到达这个地址的状态。SM为使用这种执行模式提供了捷径：<code>.explore()</code>方法。</p> 
<p>当使用<code>find</code>参数启动<code>.explore()</code>方法时，程序将会一直执行，直到发现了一个和<code>find</code>参数指定的条件相匹配的状态。<code>find</code>参数的内容可以是想要执行到的某个地址、或者想要执行到的地址列表、或者一个获取state作为参数并判断这个state是否满足某些条件的函数。当<code>active</code>stash中的任意状态和<code>find</code>中的条件匹配的时候，它们就会被放到<code>found</code>stash中，执行随即停止。之后你可以探索找到的状态，或者决定丢弃它，转而探索其它状态。你还可以按照和<code>find</code>相同的格式设置另一个参数——<code>avoid</code>。当一个状态和<code>avoid</code>中的条件匹配时，它就会被放进<code>avoided</code>stash中，之后继续执行。最后，<code>num_find</code>参数指定函数返回前需要找到的符合条件的状态的个数，这个参数默认是1。当然，如果<code>active</code>stash中已经没有状态可以执行，那么不论有没有找到你指定的状态个数，都会停止执行。</p> 
<p>让我们来简单看一个crackme的例子：</p> 
<p>首先我们加载这个二进制文件：</p> 
<pre data-index="67" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> proj <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a'</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<p>然后我们创建一个SM:</p> 
<pre data-index="68" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr <span class="token operator">=</span> proj<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>simgr<span class="token punctuation">(</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre> 
<p>现在我们符号执行直到我们找到一个符合我们要求的state（比如标准输出中输出“Congrats”）：</p> 
<pre data-index="69" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> simgr<span class="token punctuation">.</span>explore<span class="token punctuation">(</span>find<span class="token operator">=</span><span class="token keyword">lambda</span> s<span class="token punctuation">:</span> <span class="token string">b"Congrats"</span> <span class="token keyword">in</span> s<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>SimulationManager <span class="token keyword">with</span> <span class="token number">1</span> active<span class="token punctuation">,</span> <span class="token number">1</span> found<span class="token operator">&gt;</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre> 
<p>现在我们就可以从这个状态中获得flag啦～：</p> 
<pre data-index="70" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s <span class="token operator">=</span> simgr<span class="token punctuation">.</span>found<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Enter password<span class="token punctuation">:</span> Congrats!

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> flag <span class="token operator">=</span> s<span class="token punctuation">.</span>posix<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
g00dJ0B!
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<h4><a name="t35"></a><a id="Exploration_Techniques_1487"></a>探索技术（Exploration Techniques）</h4> 
<p>angr封装了几个功能使你能够自定义SM的行为，这些功能被称为"探索技术"。为什么你会需要探索技术呢？一个典型的例子是，你想修改程序状态空间的探索模式——默认是“每个state只执行一次”的广度优先搜索策略。但如果使用探索技术，你可以实现诸如深度优先搜索。然而这些探索技术能做的事(instrumentation power of these techniques)远比这些灵活——你可以完全改变angr单步执行的行为。在之后的章节里，我们会介绍如何编写你自己的探索技术。</p> 
<p>调用<code>simgr.use_technique(tech)</code>使用特定的探索技术，其中<code>tech</code>是ExplorationTechnique的子类的实例。angr內建的探索技术可以在<code>angr.exploration_techniques</code>中找到.</p> 
<p>这里是一些內建探索技术的简介：</p> 
<ul><li>DFS：深度优先搜索。每次只保持一个状态是<code>active</code>的，并把其余状态都放在<code>deferred</code>stash中，直到当前active状态达到<code>deadend</code>或<code>errors</code>。</li><li>Explorer：这个技术实现了<code>.explore()</code>的功能，允许你寻找或避开某些指定的地址。</li><li>LengthLimiter: 设置每个状态能够执行的路径长度的上限。</li><li>LoopSeer：用一个循环次数的近似值来丢弃那些似乎会多次执行某个循环的状态，并把它们放入<code>spinning</code>stash中；当没有其它可执行的状态时，再把它们拉出来继续执行。</li><li>ManualMergepoint: 将程序中的某个地址作为合并点，当某个状态到达那个地址时，会被短暂地存储，之后，在指定时延内到达同一地址的状态都会被合并到这个状态。</li><li>MemoryWatcher: 监视在simgr步骤之间系统上有多少内存可用，如果内存不足就停止探索。</li><li>Oppologist:这个“operation apologist”是一个特别有趣的技术——它被开启后，当angr执行到了一个不被支持的指令（比如一个奇怪的或者外部的浮点SIMD操作）时，它将会具体化这条指令的所有输入，并且使用独角兽引擎(unicorn engine)来执行这条指令，这使得程序执行得以延续。</li><li>Spiller: 当<code>active</code>stash中有过多状态时，这项技术将会把其中的一些dump到硬盘上来保证低内存消耗。</li><li>Threading: 对程序的单步执行加入线程级并发支持。由于python全局解释器的锁定，这并没有什么帮助，但是如果你有一个程序在分析时花费了大量时间在angr的本地代码依赖上，这个技术可能会起到加速效果。</li><li>Tracer: 一种使程序按照从其他资源获得动态追踪记录执行的探索技术（类似于复现某次执行过程？）。这个<a href="https://github.com/angr/tracer">动态跟踪仓库</a><br> 里有一些工具能够产生这些路径。</li><li>Veritesting:：是一篇CMU论文中提及的自动化定义合并点的方法的实现。这很有用，你可以通过在SM的构造函数中传入<code>veritesting=True</code>来启用它。注意这个技术通常不能和其余技术很好地兼容，因为它使用了入侵的方式来实现静态符号执行。</li></ul> 
<h3><a name="t36"></a><a id="Execution_Engines_1508"></a>执行引擎(Execution Engines)</h3> 
<p>当你用angr进行一次单步执行时，必须有一个东西来切实地将程序执行一步（即一个基本块，下面简称执行一个基本块为step）。angr使用一系列引擎（<code>SimEngine</code>的子类）来模拟被执行的代码对输入状态产生的影响。angr的执行内核将按序尝试列表中可用的引擎，并取出第一个能够处理当前step的引擎。下面是按序列出的默认引擎列表：</p> 
<ul><li>failure engine：当前一次step将我们带到一个不可继续执行的状态时，故障引擎启动。</li><li>syscall engine：当前一次step以一个系统调用结束时启动。</li><li>hook engine：当前地址被hook时启动。</li><li>unicorn engine：当<code>UNICORN</code>选项被开启并且输入状态中没有符号化的数据时启动。</li><li>VEX engine：作为最终的回调函数被调用。</li></ul> 
<h4><a name="t37"></a><a id="SimSuccessors_1518"></a>SimSuccessors</h4> 
<p>实际上按顺序尝试上述列表中的执行引擎的代码位于<code>project.factory.successors(state, **kwargs)</code>中，这个方法会将接收到的参数传给每一个引擎。它是<code>state.step()</code>和<code>simulation_manager.step()</code>的核心。它返回一个我们之前已经简要讨论过的<code>SimSuccessor</code>对象。<code>SimSuccessor</code>的目的是对产生的后继状态进行一个简单的分类，并将这些状态分别存储在不同的属性（列表类型）中，这些属性是：</p> 
<div class="table-box"><table><thead><tr><th>属性</th><th>条件</th><th>指令指针</th><th>描述</th></tr></thead><tbody><tr><td>successors</td><td>True（可以是约束为True的符号表达式；译者注：按我理解就是状态的约束条件可满足）</td><td>可以是带符号的指令，但是解的个数必须小于或等于256个；详见<code>unconstrained_successors</code>）</td><td>由引擎执行某个状态后产生的普通的、可满足的状态。它的指令指针可以是符号化的（例如，以用户输入为判断条件的跳转指令），因此这个列表中存储的状态可能实际产生多个后继状态</td></tr><tr><td>unsat_successors</td><td>False(可以是约束为False的符号表达式；译者注：即符号约束条件不可满足)</td><td>可以是带符号的指令</td><td>不可满足的后继状态。这些状态的约束条件不可能被满足（例如：不可能执行的跳转，或者必须被默认执行的跳转。）</td></tr><tr><td>flat_successors</td><td>True(可以是约束为True的符号表达式)</td><td>具体指令（不带符号）</td><td>正如之前强调的，在<code>successors</code>列表中的状态中的指令指针可以是带符号的，这就带来一个问题：在执行一次step时（比如在<code>SimEngineVEX.process</code>中向前执行一步），我们假设一个state只能够代表代码中单独一段代码的执行结果，但是如果前一个状态是带符号的，那么执行结果应该如何表示呢？为了解决这个问题，当在<code>successors</code>列表中遇到一个带有符号化指令指针的状态时，angr会计算出所有可能的符号状态的具体值（最多256种可能，如果超过这个限制，将会被放入其他属性的列表中），我们称这个计算过程为<code>flattening</code>。在<code>flat_successors</code>中的每个状态都有着不带符号且互不相同的指令指针。例如，如果在<code>successors</code>列表中发现一个状态的指令指针指向<code>X+5</code>，且X的约束条件是<code>X &gt; 0x800000</code>且<code>X &lt; 0x800010</code>，那么我们会将它“flatten”为16个不同的<code>flat_sucessors</code>状态，这16个状态包含的指令指针值从<code>0x800006</code>一直到<code>0x800015</code></td></tr><tr><td>unconstrained_successors</td><td>True（可以是约束为True的符号表达式）</td><td>符号化的指令指针（符号表达式的解的个数多于256个）</td><td>在上面描述的flattening过程中，如果发现一个状态内的符号表达式组的可行解多于256个，我们就假设这个指令指针的值是一个不受约束的数据（例如，用户输入导致的栈溢出）这个假设通常是不合理的（译者注：wtf？！）。像这样的状态就会被放在<code>unconstrained_successors</code>列表中，而不是<code>successors</code>列表中</td></tr><tr><td>all_successors</td><td>任何条件</td><td>可以是符号化的</td><td><code>successors</code>+<code>unsat_successors</code>+<code>unconstrained_successors</code></td></tr></tbody></table></div> 
<h4><a name="t38"></a><a id="Breakpoints_1530"></a>断点(Breakpoints)</h4> 
<p>和其他执行引擎一样，angr支持断点的设置。这就很酷了！一个断点可以这么下：</p> 
<pre data-index="71" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> angr
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> angr<span class="token punctuation">.</span>Project<span class="token punctuation">(</span><span class="token string">'examples/fauxware/fauxware'</span><span class="token punctuation">)</span>

<span class="token comment"># 得到一个state</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s <span class="token operator">=</span> b<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>entry_state<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 添加一个断点。在内存写之前，这个断点将被放到ipdb中。</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>b<span class="token punctuation">(</span><span class="token string">'mem_write'</span><span class="token punctuation">)</span>

<span class="token comment">#另一方面，我们可以在一个内存写操作发生后马上触发一个断点。</span>
<span class="token comment"># 允许自定义断点触发后的回调函数（需要ipdb库的支持）</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">def</span> <span class="token function">debug_func</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"State %s is about to do a memory write!"</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>b<span class="token punctuation">(</span><span class="token string">'mem_write'</span><span class="token punctuation">,</span> when<span class="token operator">=</span>angr<span class="token punctuation">.</span>BP_AFTER<span class="token punctuation">,</span> action<span class="token operator">=</span>debug_func<span class="token punctuation">)</span>

<span class="token comment"># 触发断点后进入ipython的交互界面。</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>b<span class="token punctuation">(</span><span class="token string">'mem_write'</span><span class="token punctuation">,</span> when<span class="token operator">=</span>angr<span class="token punctuation">.</span>BP_AFTER<span class="token punctuation">,</span> action<span class="token operator">=</span>angr<span class="token punctuation">.</span>BP_IPYTHON<span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li></ul></pre> 
<p>除了“内存写”断点外，还有许多其他种类的断点。这里是一个断点事件触发列表，你可以设置在这些事件发生前还是发生后触发断点：</p> 
<div class="table-box"><table><thead><tr><th>事件类型</th><th>事件含义</th></tr></thead><tbody><tr><td>mem_read</td><td>内存正在被读取</td></tr><tr><td>mem_write</td><td>内存正在被写</td></tr><tr><td>reg_read</td><td>寄存器正在被读</td></tr><tr><td>reg_write</td><td>寄存器正在被写</td></tr><tr><td>tmp_read</td><td>一个临时值（立即数？）正在被读</td></tr><tr><td>temp_write</td><td>一个临时值正在被写</td></tr><tr><td>expr</td><td>一个表达式正在被建立（比如一次数学计算的结果，或者IR中的常量（a constant in the IR））</td></tr><tr><td>statement</td><td>一个IR statement正在被解释执行(translate)</td></tr><tr><td>instruction</td><td>一个新的（本地native）指令正在被解释执行</td></tr><tr><td>lrsb</td><td>一个新的基本块正在被解释执行</td></tr><tr><td>constraints</td><td>一个新的约束正在被加入某个状态中</td></tr><tr><td>exit</td><td>一个继承状态正由一次执行中产生</td></tr><tr><td>symbolic_variable</td><td>一个新的符号变量正在被创建</td></tr><tr><td>call</td><td>一个call指令正在被执行</td></tr><tr><td>address_concretization</td><td>一个符号化的内存值正在被解析</td></tr></tbody></table></div> 
<p>对于上述不同的事件，可以应用不同的属性（来限制断点触发的条件）：</p> 
<div class="table-box"><table><thead><tr><th>事件类型</th><th>属性名</th><th>适用的时机</th><th>属性含义</th></tr></thead><tbody><tr><td>mem_read</td><td>mem_read_address</td><td>BP_BEFOR 或 BP_AFTER</td><td>正在被读取的内存的地址</td></tr><tr><td>mem_read</td><td>mem_read_length</td><td>BP_BEFOR 或 BP_AFTER</td><td>读取的内存的长度</td></tr><tr><td>mem_read</td><td>mem_read_expr</td><td>BP_AFTER</td><td>地址中的表达式</td></tr><tr><td>mem_write</td><td>mem_write_address</td><td>BP_BEFOR 或 BP_AFTER</td><td>正在被写入的内存地址</td></tr><tr><td>mem_write</td><td>mem_write_length</td><td>BP_BEFOR 或 BP_AFTER</td><td>写入内存的长度</td></tr><tr><td>mem_write</td><td>mem_write_expr</td><td>BP_BEFOR 或 BP_AFTER</td><td>写入内存的表达式</td></tr><tr><td>reg_read</td><td>reg_read_offset</td><td>BP_BEFOR 或 BP_AFTER</td><td>被读取的寄存器的偏移</td></tr><tr><td>reg_read</td><td>reg_read_length</td><td>BP_BEFOR 或 BP_AFTER</td><td>被读取寄存器的值的长度</td></tr><tr><td>reg_read</td><td>reg_read_expr</td><td>BP_BEFOR 或 BP_AFTER</td><td>被读取的寄存器中的表达式</td></tr><tr><td>reg_write</td><td>reg_write_length</td><td>BP_BEFOR 或 BP_AFTER</td><td>被写入寄存器数据的长度</td></tr><tr><td>reg_write</td><td>reg_write_expr</td><td>BP_BEFOR 或 BP_AFTER</td><td>被写入寄存器的表达式</td></tr><tr><td>tmp_read</td><td>tmp_read_num</td><td>BP_BEFOR 或 BP_AFTER</td><td>被读入的临时值的长度</td></tr><tr><td>tmp_read</td><td>tmp_read_expr</td><td>BP_AFTER</td><td>被读入的临时表达式</td></tr><tr><td>tmp_write</td><td>tmp_write_num</td><td>BP_BEFOR 或 BP_AFTER</td><td>被写入临时值的数</td></tr><tr><td>tmp_write</td><td>tmp_write_expr</td><td>BP_AFTER</td><td>被写入临时值的表达式</td></tr><tr><td>expr</td><td>expr</td><td>BP_AFTER</td><td>表达式的值</td></tr><tr><td>statement</td><td>statement</td><td>BP_AFTER 或BP_BEFOR</td><td>IR在其所在的基本块中的索引值（即断在当前基本块中的索引值）</td></tr><tr><td>instruction</td><td>instruction</td><td>BP_BEFORE 或 BP_AFTER</td><td>本地指令的地址</td></tr><tr><td>irsb</td><td>address</td><td>BP_BEFORE 或 BP_AFTER</td><td>基本块地址</td></tr><tr><td>constraints</td><td>added_constraints</td><td>BP_BEFORE 或 BP_AFTER</td><td>被加入的约束的列表</td></tr><tr><td>call</td><td>function_address</td><td>BP_BEFORE 或 BP_AFTER</td><td>被调用的函数名</td></tr><tr><td>exit</td><td>exit_target</td><td>BP_BEFORE 或 BP_AFTER</td><td>代表SimExit的目标的表达式</td></tr><tr><td>exit</td><td>exit_guard</td><td>BP_BEFORE 或 BP_AFTER</td><td>代表SimExit的限制的表达式</td></tr><tr><td>exit</td><td>jumpkind</td><td>BP_BEFORE 或 BP_AFTER</td><td>代表SimExit的种类的表达式</td></tr><tr><td>symbolic_variable</td><td>symbolic_name</td><td>BP_BEFORE 或 BP_AFTER</td><td>正在被创建的符号变量的名字。解析引擎可能改变这个名字（通过在后面添加唯一的ID和长度）。检查symbolic_expr来得到最终的符号表达式</td></tr><tr><td>symbolic_variable</td><td>symbolic_size</td><td>BP_BEFORE 或 BP_AFTER</td><td>正在被创建的符号变量的长度</td></tr><tr><td>symbolic_variable</td><td>symbolic_expr</td><td>BP_AFTER</td><td>代表新的符号变量的符号表达式</td></tr><tr><td>address_concretization</td><td>address_concretization_strategy</td><td>BP_BEFORE 或 BP_AFTER</td><td>被用于解析地址的SimConcretizationStrategy。断点处理函数可以改变将要被应用于解析当前地址的策略。如果你的断点处理函数被置为None，这个策略就会被忽略</td></tr><tr><td>address_concretization</td><td>address_concretization_action</td><td>BP_BEFORE 或 BP_AFTER</td><td>用于记录内存操作的SimAction对象</td></tr><tr><td>address_concretization</td><td>address_concretization_memory</td><td>BP_BEFORE 或 BP_AFTER</td><td>被操作的SimMemory对象</td></tr><tr><td>address_concretization</td><td>address_concretization_expr</td><td>BP_BEFORE 或 BP_AFTER</td><td>代表正在被解析的地址的AST。断点处理函数可以改变这个来影响正在被解析的地址</td></tr><tr><td>address_concretization</td><td>address_concretization_add_constraints</td><td>BP_BEFORE 或 BP_AFTER</td><td>约束是否应该别加入到这次读取中</td></tr><tr><td>address_concretization</td><td>address_concretization_result</td><td>BP_AFTER</td><td>被解析的地址列表(整型数)。断点处理函数可以覆盖这个来产生不同的解析结果。</td></tr></tbody></table></div> 
<p>你可以在合适的断点回调函数中通过通过<code>state.inspect</code>来访问这些属性，你甚至可以改变这些值来影响这些属性的后续使用！</p> 
<pre data-index="72" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">def</span> <span class="token function">track_reads</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Read'</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>mem_read_expr<span class="token punctuation">,</span> <span class="token string">'from'</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>mem_read_address<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>b<span class="token punctuation">(</span><span class="token string">'mem_read'</span><span class="token punctuation">,</span> when<span class="token operator">=</span>angr<span class="token punctuation">.</span>BP_AFTER<span class="token punctuation">,</span> action<span class="token operator">=</span>track_reads<span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre> 
<p>另外，这些属性都可以作为<code>inspect.b</code>的关键字参数来使用，这可以使得断点更加准确</p> 
<pre data-index="73" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 将会在程序可能(考虑到符号化的地址)往0x1000地址处写之前断下</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>b<span class="token punctuation">(</span><span class="token string">'mem_write'</span><span class="token punctuation">,</span> mem_write_address<span class="token operator">=</span><span class="token number">0x1000</span><span class="token punctuation">)</span>

<span class="token comment"># 将会在程序只能往内存0x1000处写数据之前断下</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>b<span class="token punctuation">(</span><span class="token string">'mem_write'</span><span class="token punctuation">,</span> mem_write_address<span class="token operator">=</span><span class="token number">0x1000</span><span class="token punctuation">,</span> mem_write_address_unique<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

<span class="token comment"># 将会在指令地址0x8000执行后生效，但是只有0x1000是从内存中读出的表达式的可行解</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>b<span class="token punctuation">(</span><span class="token string">'instruction'</span><span class="token punctuation">,</span> when<span class="token operator">=</span>angr<span class="token punctuation">.</span>BP_AFTER<span class="token punctuation">,</span> instruction<span class="token operator">=</span><span class="token number">0x8000</span><span class="token punctuation">,</span> mem_read_expr<span class="token operator">=</span><span class="token number">0x1000</span><span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre> 
<p>实际上，我们甚至可以指定一个函数作为条件：</p> 
<pre data-index="74" class="set-code-show prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment"># 展示如何用函数表示复杂条件，用这种方式几乎可以做任何事! 例子中将会保证断下时RAX的值是0x41414141 并且</span>
<span class="token comment"># 从地址0x8004开始的基本块在这个state的执行历史中</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">def</span> <span class="token function">cond</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>regs<span class="token punctuation">.</span>rax<span class="token punctuation">,</span> cast_to<span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'AAAA'</span> <span class="token keyword">and</span> <span class="token number">0x8004</span> <span class="token keyword">in</span> state<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>backtrace

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>b<span class="token punctuation">(</span><span class="token string">'mem_write'</span><span class="token punctuation">,</span> condition<span class="token operator">=</span>cond<span class="token punctuation">)</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li></ul></pre> 
<blockquote> 
 <p>state.eval 或为state.solver.eval</p> 
</blockquote> 
<h5><a id="mem_read_1648"></a>注意内存读取<code>mem_read</code>断点</h5> 
<p><code>mem_read</code>断点在执行程序或二进制分析读取内存时被触发。如果您在<code>mem_read</code>上使用断点，并且还使用<code>state.mem</code>从内存地址加载数据，那么您应该知道，在技术上读取内存时，断点将被触发。</p> 
<p>因此，如果希望从内存加载数据而不触发已经设置的任何<code>mem_read</code>断点，那么可以使用<code>state.memory.load</code>和关键字参数<code>disable_actions=True</code>和<code>inspect=False</code>。</p> 
<p>对于<code>state.find</code>也是如此，您可以使用相同的关键字参数来防止触发<code>mem_read</code>断点。</p> 
<h3><a name="t39"></a><a id="Analyses_1656"></a>分析(Analyses)</h3> 
<p>angr的目标是使得对二进制程序的分析更加简单。学习至此，angr允许你将分析代码打包为一个通用的格式，以便于应用到任何project的分析中。我们将会在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.angr.io%2Fdocs%2Fanalysis_writing.html" rel="nofollow">之后的部分</a>中教你如何写你自己的分析代码，但是基本的思想是所有的分析都在<code>project.analyses</code>中（例如，<code>project.analyses.CFGFast()</code>）且可以被作为一个方法来调用，返回一个分析结果的实例。</p> 
<h4><a name="t40"></a><a id="_1660"></a>內建分析函数</h4> 
<div class="table-box"><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>CFGFast</td><td>构建一个快速的程序控制流图</td></tr><tr><td><a href="https://docs.angr.io/built-in-analyses/cfg" rel="nofollow">CFGEmulated</a></td><td>就构建一个精确的程序控制流图</td></tr><tr><td>VFG</td><td>对程序中的每个方法都执行VSA，创建一个值流图(Value Flow Graph)并检测栈变量</td></tr><tr><td><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.angr.io%2Fdocs%2Fanalyses%2Fdfg.md" rel="nofollow">DFG</a></td><td>为每个在CFG中出现的基本块构建数据流图</td></tr><tr><td><a href="https://docs.angr.io/built-in-analyses/backward_slice" rel="nofollow">BackwardSlice</a></td><td>有目的地为程序计算一个Backward Slice</td></tr><tr><td><a href="https://docs.angr.io/built-in-analyses/identifier" rel="nofollow">Identifier</a></td><td>定义CGC二进制文件中的通用库函数</td></tr><tr><td>更多！</td><td>angr有许多的分析函数，大多数都可以使用！如果你想要知道如何使用某个分析函数，你可以在github上提交一个issue来获取相应的文档</td></tr></tbody></table></div> 
<h4><a name="t41"></a><a id="Resilience_1672"></a>容错（Resilience）</h4> 
<p>分析函数可以有较好的容错性，并且基本上能够catch和记录所有错误。这些错误被记录为<code>analysis</code>的<code>errors</code>或者<code>named_errors</code>属性，具体被记录为哪种属性取决于这个错误是如何被抓出的。然而，你可能想要以“fail fast”模式运行一次分析，从而忽略那些错误。为了达到这个目的，你可以给<code>analysis</code>的构造函数传入一个<code>fail_fast=True</code>的参数。</p>
                </div><div><div></div></div>
                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-f23dff6052.css" rel="stylesheet">
                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-c216769e99.css" rel="stylesheet">
        </div>