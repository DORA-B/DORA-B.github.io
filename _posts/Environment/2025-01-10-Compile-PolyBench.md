---
title: Assembly of computer
date: 2025-01-10
categories: [Environment]
tags: [linux]     # TAG names should always be lowercase
published: false
---

# Problem description
I have a problem when I probed into the QEMU's qlog file to see the layout of the guest's binary assembly code.

```asm

----------------
IN: 
0x3fe6b04c:  e28d0010  add      r0, sp, #0x10
0x3fe6b050:  eb0052f6  bl       #0x3fe7fc30

OUT: [size=72]
  -- guest addr 0x3fe6b04c + tb prologue
0x7f221df22380:  8b 5d f8                 movl     -8(%rbp), %ebx
0x7f221df22383:  85 db                    testl    %ebx, %ebx
0x7f221df22385:  0f 8c 22 00 00 00        jl       0x7f221df223ad
0x7f221df2238b:  8b 5d 34                 movl     0x34(%rbp), %ebx
0x7f221df2238e:  83 c3 10                 addl     $0x10, %ebx
0x7f221df22391:  89 5d 00                 movl     %ebx, (%rbp)
  -- guest addr 0x3fe6b050
0x7f221df22394:  c7 45 38 54 b0 e6 3f     movl     $0x3fe6b054, 0x38(%rbp)
0x7f221df2239b:  c7 45 3c 30 fc e7 3f     movl     $0x3fe7fc30, 0x3c(%rbp)
0x7f221df223a2:  48 8b fd                 movq     %rbp, %rdi
0x7f221df223a5:  ff 15 15 00 00 00        callq    *0x15(%rip)
0x7f221df223ab:  ff e0                    jmpq     *%rax
0x7f221df223ad:  48 8d 05 0f ff ff ff     leaq     -0xf1(%rip), %rax
0x7f221df223b4:  e9 5f 6c f6 ff           jmp      0x7f221de89018
  -- tb slow paths + alignment
0x7f221df223b9:  90                       nop      
0x7f221df223ba:  90                       nop      
0x7f221df223bb:  90                       nop      
0x7f221df223bc:  90                       nop      
0x7f221df223bd:  90                       nop      
0x7f221df223be:  90                       nop      
0x7f221df223bf:  90                       nop      
  data: [size=8]
0x7f221df223c0:  .quad  0x0000560a08a42790

----------------
IN: 
0x3fe7fc30:  e3a01000  mov      r1, #0
0x3fe7fc34:  eaffffc9  b        #0x3fe7fb60

OUT: [size=55]
  -- guest addr 0x3fe7fc30 + tb prologue
0x7f221df224c0:  8b 5d f8                 movl     -8(%rbp), %ebx
0x7f221df224c3:  85 db                    testl    %ebx, %ebx
0x7f221df224c5:  0f 8c 20 00 00 00        jl       0x7f221df224eb
0x7f221df224cb:  c7 45 04 00 00 00 00     movl     $0, 4(%rbp)
  -- guest addr 0x3fe7fc34
0x7f221df224d2:  90                       nop      
0x7f221df224d3:  e9 00 00 00 00           jmp      0x7f221df224d8
0x7f221df224d8:  c7 45 3c 60 fb e7 3f     movl     $0x3fe7fb60, 0x3c(%rbp)
0x7f221df224df:  48 8d 05 1a ff ff ff     leaq     -0xe6(%rip), %rax
0x7f221df224e6:  e9 2d 6b f6 ff           jmp      0x7f221de89018
0x7f221df224eb:  48 8d 05 11 ff ff ff     leaq     -0xef(%rip), %rax
0x7f221df224f2:  e9 21 6b f6 ff           jmp      0x7f221de89018
```
I have several demands when I want to get from the guest's block.
1. Simple instructions: make the conditional instructions as few as possible.
2. Localizatin: only get the assembly code from the orignal polybench's functions, excluding those from the standard library.
3. Compact, clear and intact: in one single assembly file compiled from source .c file, it should contain all the assembly code from the functions (both in the current .c and the needed common functions from other files.)
4. Combination with QEMU. Need to find the relation between the QEMU's qlog and the original assembly's sections, means that need to find and extract the corresponding blocks.

# Solutions

## 1. Why do I still see conditional instructions in .plt even though I disabled if-conversion?

`-fno-if-conversion` and `-fno-if-conversion2` are passes that prevent GCC from transforming conditional branches into conditional “select” instructions.

The .plt (Procedure Linkage Table) is automatically generated by the linker for dynamic symbol resolution of external functions. The code in .plt is not directly governed by your `-fno-if-conversion` or other typical per-function optimizations.
The instructions in .plt can still use conditional branches or conditional execution sequences if needed by the ABI or the linker stubs.
In other words, .plt is out of your control from a typical “disable certain compiler passes” standpoint. The compiler and linker produce .plt for dynamic linking, symbol resolution, and GOT (Global Offset Table) lookups.
Hence, even if you disable certain conditional conversions in your own code, you will still see various instructions in .plt that the linker or runtime expects.

## 2. The difference between .plt and .text, and why do I see __aeabi_ui2d, __aeabi_dmul, etc.?

- .text section: This is where most of your executable code (the compiled instructions from your .c files) goes.
- .plt section: This is the “Procedure Linkage Table.” It contains small chunks of code used at runtime to jump to the correct location of externally linked functions. If you dynamically link against libraries (like the C library), the .plt stubs are used to resolve function addresses the first time they are called.

When you compile for ARM using the EABI (Embedded ABI), you often see “AEABI routines” such as:
`__aeabi_ui2d`: convert unsigned int to double
`__aeabi_dmul`: multiply two doubles
…and so on.
These routines are part of the ARM ABI and often come from compiler runtime libraries (e.g., libgcc, libc, or libm). They implement certain floating-point or integer operations in a consistent way across different hardware.
If your target hardware does not have certain floating-point instructions or you’re using soft-float, you’ll see more of these helper routines.

### Minimizing or removing AEABI calls with gnueabihf

If you switch from `gnueabi` (soft float) to `gnueabihf` (hard float) and your CPU supports hardware floating-point instructions, you’ll typically see fewer software routines like __aeabi_dmul, because the compiler can generate direct hardware FPU instructions (e.g., vmul.f64) for floating-point operations instead of function calls.
You can try a cross-toolchain with `arm-linux-gnueabihf-gcc` plus flags like `-march=armv7` `-mfloat-abi=hard` `-mfpu=...` (depending on your CPU’s floating-point unit). Then your code may rely more on hardware instructions and less on the AEABI stubs.

## 3.  How can I get all the ASM code in one file

1. Generate a single assembly file from your entire build

```bash
arm-linux-gnueabi-gcc -S 2mm.c -o 2mm.s \
    -O2 -DPOLYBENCH_DUMP_ARRAYS -DPOLYBENCH_USE_C99_PROTO \
    -march=armv7 -fno-if-conversion -fno-if-conversion2 -fno-tree-loop-if-convert \
    -I. -I../../../utilities ../../../utilities/polybench.c
```
This command will produce a .s file (assembly) that should contain all of the compiled code for both 2mm.c and polybench.c.

Note that you must ensure you supply all the .c sources you want in the same single compile command if you want one .s containing them.

2. Link-time or “whole-program” approach

- Another approach is to compile each .c to .o files and then link them, but that typically yields multiple .o files. If you want a single .s, you do it in one pass or a final link step.
- However, you usually won’t get the .plt, .text, and other linker-generated sections directly in that .s. The .plt is typically created by the linker step.
- If you truly want to see the final layout (with .plt, etc.), you might look at `objdump -d a.out > full.s`, which disassembles the entire final binary into a single text file. This includes all sections (like .plt, .got, .data, etc.).
So for a single compiled assembly source, do everything in one command with the -S flag. If you want a disassembly of the final linked object, use objdump -d.

## 4. assembly labels or sections in the disassembly that go unused in the actual code flow, and how to produce a more “compact” assembly listing that excludes genuinely unused parts.

### Why Might There Be Unused Labels or Sections?
- Linker-Generated Stubs (.plt, dynamic linking, etc.):
Even if you never explicitly call certain external functions, the linker or runtime might insert Procedure Linkage Table (PLT) entries, GOT entries, or other stubs. These can appear in your final binary even if they end up never being used at runtime.

- Default Library Implementations:
The C library (and its associated runtime libraries) sometimes provides multiple routines or fallback code paths. Some of them may not be referenced at all by your program, yet are included unless you explicitly configure the compiler and linker to remove unused sections.

- Multiple-Object Linking, Static Libraries, or Weak Symbols:
If you link against libraries or produce a statically linked binary, entire object files from a static library might be pulled in even if only a portion is used. This can result in “extra” symbols and code getting included.

- Compiler/Linker Options (Lack of Section Splitting):
By default, each .o file is one unit from the linker’s perspective. If that .o file has five functions, but you only call one of them, the other four can still get included if the compiler doesn’t split them into separate sections.

### How to Remove Truly Unused Code or Labels
(A) Use `-ffunction-sections` and `-fdata-sections`
- `-ffunction-sections` places each function in its own .text.<function_name> section.
- `-fdata-sections` places each global variable in its own .data.<var_name> section.
Then at link time, the linker can safely discard the sections that are not referenced by any other code.
(B) Use -Wl,--gc-sections during linking
The linker option `--gc-sections` enables “garbage collection” of unused sections.
Combined with `-ffunction-sections` -fdata-sections, it can remove all unreferenced functions or data from the final binary.

```bash
arm-linux-gnueabi-gcc -o myprog myprog.c -O2 \
    -ffunction-sections -fdata-sections \
    -Wl,--gc-sections
```
(C) Consider Static vs. Dynamic Linking
- Static linking (-static) can sometimes let the linker omit entire library routines if not used.
- Dynamic linking can create .plt entries for each symbol that might possibly be needed at runtime, even if your code doesn’t use them. In that case, you’ll typically see extra PLT stubs in the disassembly.
- If your goal is a minimal final binary, you might try static linking with a smaller C library (like newlib or musl) plus `--gc-sections`, but this depends on your project’s constraints.

## 5. Differences between the assembly files  


1. 2mm.s generated directly from file.

```bash
$(CC) -S 2mm.c
```

Only asking the compiler to generate raw assembly code for that single source file before any linking occurs. In contrast, 

2. 2mm.s generated from binary file.

```bash
objdump -d a.out
```
(where `a.out` or `2mm` is the **fully linked** final binary), you are **disassembling the complete, linked program**. This difference in stages—compilation vs. final linking—is why you see `.plt` sections in the objdump output but not in the compiler-generated `.s` file:

1. **`.plt` is created by the linker**
    
    * The Procedure Linkage Table (`.plt`) is part of the dynamic linking machinery. It only appears in the **fully linked** ELF binary (or other object format).
    * The compiler alone does not generate `.plt` code; that’s the job of the **linker** (e.g., `ld`) when you link against shared libraries.
2. **Different section layouts**
    
    * The compiler’s `-S` output usually places each function in a default section (`.text` or `.text.<function>`), but it has **no** final addresses, no `.plt`, and no GOT references spelled out. It also tends to produce pseudo-instructions for external calls (e.g., `bl polybench_alloc_data(PLT)`), but no final addresses.
    * The **linked** binary has many additional sections like `.plt`, `.got`, `.data`, etc., assigned real addresses. The `objdump -d` view shows these sections with their final addresses.
3. **Compiler stage vs. Linker stage**
    
    * `-S 2mm.c` stops after the front-end/back-end compilation, handing you an unlinked assembly file.
    * The linker merges all object files, resolves symbols, and (if you are dynamically linking) creates a `.plt` stub for each external function so that lazy binding and dynamic resolution can happen at runtime.

Hence, the “layout differences” you see:

* **`2mm.s`** from `$(CC) -S`:
    
    * No `.plt`
    * Single-file view
    * No final addresses, relocations, or references to dynamic sections
* **`objdump -d 2mm`** (the final ELF binary):
    
    * `.plt` / `.text` / other sections visible
    * Actual addresses for instructions
    * Possibly references to external library calls or data in `.got` / `.got.plt`

That is why the disassembly from the final executable is split into `.plt` (and other sections) with real addresses, while the compiler-generated `.s` only shows the unlinked code for your one source file.

