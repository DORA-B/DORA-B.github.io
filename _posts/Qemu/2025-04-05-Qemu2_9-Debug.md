---
title: Debug in Qemu
date: 2025-04-05
categories: [Qemu]
tags: [qemu]     # TAG names should always be lowercase
published: false
---

> This blog is used to show should important process and data structures in QEMU 2.6 and 9.0, which are mixed together


# Debug QEMU 2.6 

- configure and compile the user mode qemu.
```shell
../configure     --target-list=arm-linux-user  --enable-debug   --extra-cflags="-fPIC -O2"     --extra-ldflags="-fPIC -pie"     --disable-werror     --disable-stack-protector
```
- more verbose
```shell
../configure --target-list=arm-linux-user \
             --enable-debug   \
             --disable-werror \
             --disable-pie    \
             --extra-cflags="-O0 -g3" \
             --extra-ldflags=""
```
- in `--enable-debug` choice
```shell
debug_tcg="yes"
debug="yes"
strip_opt="no"
fortify_source="no"
```
- execute the binary and debug
```shell
# cmd 1
gdb --args arm-linux-user/qemu-arm ../test_arm_bin/chomp
# cmd 2
gdb --args ./arm-linux-user/qemu-arm -d in_asm,out_asm ../test_arm_bin/chomp
# cmd 3, load pre-saved bps
gdb -x ../test_arm_bin/breakpoints.gdb --args ./arm-linux-user/qemu-arm ../test_arm_bin/chomp
```

- The differences when add `-d in_asm, out_asm`: enable debug print of the translation block information


| Feature | `cpu_exec()` | `cpu_exec_nocache()` |
| --- | --- | --- |
| Return| Next tb| None|
| Uses TB cache | Yes | No |
| Speed | Faster | Slower (no reuse) |
| Used for | Normal execution | Precise 1-off execution |
| Purpose | Run guest code efficiently | Run a fixed number of instructions (e.g., for replay, exception injection, or precise control) |

- Detailed description (QEMU2.6)

```shell
qingchen@blaster:~/Github/qemu-rule-based$ ./build_rule/qemu-arm -d -help
Log items (comma separated):
out_asm         show generated host assembly code for each compiled TB
in_asm          show target assembly code for each compiled TB
op              show micro ops for each compiled TB
op_opt          show micro ops after optimization
op_ind          show micro ops before indirect lowering
int             show interrupts/exceptions in short format
exec            show trace before each executed TB (lots of logs)
cpu             show CPU registers before entering a TB (lots of logs)
fpu             include FPU registers in the 'cpu' logging
mmu             log MMU-related activities
pcall           x86 only: show protected mode far calls/returns/exceptions
cpu_reset       show CPU state before CPU resets
unimp           log unimplemented functionality
guest_errors    log when the guest OS does something invalid (eg accessing a non-existent register)
page            dump pages at beginning of user mode emulation
nochain         do not chain compiled TBs so that "exec" and "cpu" show complete traces
plugin          output from TCG plugins
strace          log every user-mode syscall, its input, and its result
tid             open a separate log file per thread; filename must contain '%d'
vpu             include VPU registers in the 'cpu' logging
trace:PATTERN   enable trace events

Use "-d trace:help" to get a list of trace events.
```
- Detailed description (QEMU 9.0)
```shell
./arm-linux-user/qemu-arm -d -help
Log items (comma separated):
out_asm         show generated host assembly code for each compiled TB
in_asm          show target assembly code for each compiled TB
op              show micro ops for each compiled TB
op_opt          show micro ops (x86 only: before eflags optimization) and after liveness analysis
int             show interrupts/exceptions in short format
exec            show trace before each executed TB (lots of logs)
cpu             show CPU registers before entering a TB (lots of logs)
mmu             log MMU-related activities
pcall           x86 only: show protected mode far calls/returns/exceptions
cpu_reset       show CPU state before CPU resets
unimp           log unimplemented functionality
guest_errors    log when the guest OS does something invalid (eg accessing a non-existent register)
page            dump pages at beginning of user mode emulation
nochain         do not chain compiled TBs so that "exec" and "cpu" show complete traces
trace:PATTERN   enable trace events

Use "-d trace:help" to get a list of trace events.

# log stdout and stderr to the output file 
> ./build_rule/qemu-arm -B 0 -d in_asm,out_asm,op,op_opt,int ./test_arm_binary/chomp > output_chmop.log 2>&1
```

- set all break points
```shell
b cpu_arm_exec
b tb_find_fast
b tb_find_slow
b tb_gen_code
b cpu_tb_exec
b decide_reg_liveness
```

```shell
1       breakpoint     keep y   0x565b6080 in cpu_loop at /workspace/linux-user/main.c:714
        breakpoint already hit 1 time
2       breakpoint     keep y   0x5657c610 in cpu_arm_exec at /workspace/cpu-exec.c:350
        breakpoint already hit 1 time
3       breakpoint     keep y   0x5657b9f0 in tb_find_fast at /workspace/cpu-exec.c:313
        breakpoint already hit 1 time
4       breakpoint     keep y   0x5657be3b in tb_find_fast at /workspace/cpu-exec.c:278
        breakpoint already hit 1 time
5       breakpoint     keep y   0x5657aa70 in tb_gen_code at /workspace/translate-all.c:1081
        breakpoint already hit 1 time
6       breakpoint     keep y   <MULTIPLE>
6.1                         y     0x5657762c in cpu_tb_exec at /workspace/cpu-exec.c:136
6.2                         y     0x5657c413 in cpu_exec_nocache at /workspace/include/qemu/log.h:50
6.3                         y     0x5657cade in cpu_arm_exec at /workspace/cpu-exec.c:138
```
- check the content of `tb`
```shell
(gdb) p *tb
$4 = {pc = 66556, cs_base = 0, flags = 524416, size = 0, icount = 0, cflags = 0, tc_ptr = 0x5676f080 <static_code_gen_buffer+32>, tc_search = 0x0, phys_hash_next = 0x0,
  orig_tb = 0x0, page_next = {0x0, 0x0}, page_addr = {0, 0}, tb_next_offset = {0, 0}, tb_jmp_offset = {0, 0}, jmp_next = {0x0, 0x0}, jmp_first = 0x0, guest_instr = 0x0}
(gdb) p tb->tc_ptr
$5 = (void *) 0x5676f080 <static_code_gen_buffer+32>
(gdb) p *(tb->tc_ptr)
Attempt to dereference a generic pointer.
(gdb) x/32bx 0x5676f080
0x5676f080 <static_code_gen_buffer+32>: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5676f088 <static_code_gen_buffer+40>: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5676f090 <static_code_gen_buffer+48>: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5676f098 <static_code_gen_buffer+56>: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
```
- disassemble TCG-generated native code, disassemble host instructions (i.e., the output of tcg_gen_code()).
```
disas /r 0x5676f080,+64
x/64i 0x5676f080
```

- Print symbol location
```shell
info address static_code_gen_buffer
```

- Print out current threads number
```shell
(gdb) info threads
  Id   Target Id         Frame
* 1    Thread 0xf7a49700 (LWP 12105) "qemu-arm" gen_intermediate_code (env=0x58796954, tb=0xe0db3058) at /workspace/target-arm/translate.c:12186
  2    Thread 0xf7a47b40 (LWP 12109) "qemu-arm" 0xf7fd7df9 in __kernel_vsyscall ()
``` 

- Show the content of the translated contents
```shell
tb->tc->ptr
p tb->tc->ptr
x/4i tb->tc->ptr
p tb->size
p/x *tb
```

```shell
(gdb) p tb
$37 = (TranslationBlock *) 0xe0db3148
(gdb) p *tb
$38 = {pc = 182948, cs_base = 0, flags = 524416, size = 20, icount = 5, cflags = 0, tc_ptr = 0x5676f430 <static_code_gen_buffer+976>,
  tc_search = 0x5676f4cf <static_code_gen_buffer+1135> "", phys_hash_next = 0x0, orig_tb = 0x0, page_next = {0x0, 0x0}, page_addr = {180224, 4294967295}, tb_next_offset = {
    65535, 132}, tb_jmp_offset = {0, 128}, jmp_next = {0x0, 0x0}, jmp_first = 0xe0db314a, guest_instr = 0xe1ec77a8}
(gdb) x/4i 0x5676f430
   0x5676f430 <static_code_gen_buffer+976>:     cmpl   $0x0,-0x4(%ebp)
   0x5676f437 <static_code_gen_buffer+983>:     jne    0x5676f4c5 <static_code_gen_buffer+1125>
   0x5676f43d <static_code_gen_buffer+989>:     mov    0x0(%ebp),%ebx
   0x5676f440 <static_code_gen_buffer+992>:     mov    0x20000(%ebx),%esi
```
- print an array in gdb
```shell
# int arr[5] = {1, 2, 3, 4, 5};
p arr          // prints the address of arr
p *arr@5       // prints all 5 elements
p *(arr+1)@3   // prints arr[1], arr[2], arr[3]
```

- look the previous frames in function call
> frame [number]
```shell
#0  0x569562c4 in static_code_gen_buffer ()
#1  0x566ee0d9 in cpu_tb_exec (cpu=0x5a689e50, itb=0x5695a3c0 <static_code_gen_buffer+118672>, tb_exit=0xff973eb0) at ../accel/tcg/cpu-exec.c:448
#2  0x566eea91 in cpu_loop_exec_tb (cpu=0x5a689e50, tb=0x5695a3c0 <static_code_gen_buffer+118672>, pc=165812, last_tb=0xff973eac, tb_exit=0xff973eb0) at ../accel/tcg/cpu-exec.c:903
#3  0x566eecaf in cpu_exec_loop (cpu=0x5a689e50, sc=0xff973f54) at ../accel/tcg/cpu-exec.c:1018
#4  0x566eed6e in cpu_exec_setjmp (cpu=0x5a689e50, sc=0xff973f54) at ../accel/tcg/cpu-exec.c:1035
#5  0x566eee11 in cpu_exec (cpu=0x5a689e50) at ../accel/tcg/cpu-exec.c:1061
#6  0x565bf0f9 in cpu_loop (env=0x5a68c380) at ../linux-user/arm/cpu_loop.c:328
#7  0x56718c55 in main (argc=2, argv=0xff974694, envp=0xff9746a0) at ../linux-user/main.c:1035
(gdb) Quit

(gdb) frame 1
#1  0x566ee0d9 in cpu_tb_exec (cpu=0x5a689e50, itb=0x5695a3c0 <static_code_gen_buffer+118672>, tb_exit=0xff973eb0) at ../accel/tcg/cpu-exec.c:448

(gdb) p *itb
$21 = {pc = 165812, cs_base = 1152, flags = 0, cflags = 0, size = 32, icount = 8, tc = {ptr = 0x5695a440 <static_code_gen_buffer+118800>, size = 443}, itree = {rb = {rb_parent_color = 1452564837, rb_right = 0x56944b24 <static_code_gen_buffer+30452>,
      rb_left = 0x569466e4 <static_code_gen_buffer+37556>}, start = 165812, last = 165843, subtree_last = 174823}, jmp_lock = {value = 0}, jmp_reset_offset = {65535, 65535}, jmp_insn_offset = {65535, 65535}, jmp_target_addr = {0, 0}, jmp_list_head = 1452665856, jmp_list_next = {0,
    0}, jmp_dest = {0, 0}, guest_instr = 0xe143dc28}
(gdb) p/x itb->pc
$22 = 0x287b4

```

## Global Debug info

```c
/* current CPU in the current thread. It is only valid inside cpu_exec() */
__thread CPUState *current_cpu;
// can be used to access the tcgcontext information
TCGContext tcg_init_ctx;
__thread TCGContext *tcg_ctx;
```

```
p/x cpu_env(current_cpu)->regs[15]

```

# Data-Structure in QEMU (Version MIXED)

## TCGContext

```c

struct TCGContext {
    uint8_t *pool_cur, *pool_end;
    
    // These manage linked lists of memory pools for small and large allocations. 
    // Pools are used to efficiently allocate memory for temporary objects during translation.
    TCGPool *pool_first, *pool_current, *pool_first_large; 
    // These counters track the number of 
    // labels, global variables, temporary variables, indirect jumps, and operations (ops) 
    // in the current translation block.
    int nb_labels;
    int nb_globals;
    int nb_temps;
    int nb_indirects;
    int nb_ops;
    TCGType addr_type;            /* TCG_TYPE_I32 or TCG_TYPE_I64 */

    int page_mask;              // aligning memory address to page boundries
    // Metadata for managing memory pages, TLB (Translation Lookaside Buffer), and instruction alignment.
    uint8_t page_bits;          
    uint8_t tlb_dyn_max_bits;
    uint8_t insn_start_words;
    TCGBar guest_mo; //Represents memory ordering constraints for guest memory operations.

    TCGRegSet reserved_regs; //Tracks which registers are reserved and cannot be used for temporary variables.
    // Manage the stack frame for the current translation block.
    intptr_t current_frame_offset;
    intptr_t frame_start;
    intptr_t frame_end;
    TCGTemp *frame_temp; // Points to a temporary variable representing the stack frame.

    TranslationBlock *gen_tb;     /* tb for which code is being generated */
    tcg_insn_unit *code_buf;      /* pointer for start of tb */
    tcg_insn_unit *code_ptr;      /* pointer for running end of tb */

#ifdef CONFIG_DEBUG_TCG
    int goto_tb_issue_mask;
    const TCGOpcode *vecop_list;
#endif

    /* Code generation.  Note that we specifically do not use tcg_insn_unit
       here, because there's too much arithmetic throughout that relies
       on addition and subtraction working on bytes.  Rely on the GCC
       extension that allows arithmetic on void*.  */
    void *code_gen_buffer;
    size_t code_gen_buffer_size;
    void *code_gen_ptr;
    void *data_gen_ptr;

    /* Threshold to flush the translated code buffer.  */
    void *code_gen_highwater;

    /* Track which vCPU triggers events */
    CPUState *cpu;                      /* *_trans */

    /* These structures are private to tcg-target.c.inc.  */
#ifdef TCG_TARGET_NEED_LDST_LABELS
    QSIMPLEQ_HEAD(, TCGLabelQemuLdst) ldst_labels;
#endif
#ifdef TCG_TARGET_NEED_POOL_LABELS
    struct TCGLabelPoolData *pool_labels;
#endif

    TCGLabel *exitreq_label;

#ifdef CONFIG_PLUGIN
    /*
     * We keep one plugin_tb struct per TCGContext. Note that on every TB
     * translation we clear but do not free its contents; this way we
     * avoid a lot of malloc/free churn, since after a few TB's it's
     * unlikely that we'll need to allocate either more instructions or more
     * space for instructions (for variable-instruction-length ISAs).
     */
    struct qemu_plugin_tb *plugin_tb;

    /* descriptor of the instruction being translated */
    struct qemu_plugin_insn *plugin_insn;
#endif

    GHashTable *const_table[TCG_TYPE_COUNT]; // Hash table for managing constants of different types
    TCGTempSet free_temps[TCG_TYPE_COUNT];
    TCGTemp temps[TCG_MAX_TEMPS]; /* globals first, temps after */

    QTAILQ_HEAD(, TCGOp) ops, free_ops;
    QSIMPLEQ_HEAD(, TCGLabel) labels;

    /*
     * When clear, new ops are added to the tail of @ops.
     * When set, new ops are added in front of @emit_before_op.
     */
    TCGOp *emit_before_op;

    /* Tells which temporary holds a given register.
       It does not take into account fixed registers */
    TCGTemp *reg_to_temp[TCG_TARGET_NB_REGS];

    uint16_t gen_insn_end_off[TCG_MAX_INSNS];
    uint64_t *gen_insn_data;

    /* Exit to translator on overflow. */
    sigjmp_buf jmp_trans;
};

```

## DisasContext
DisasContext is arch-specific, it is from target/arm/tcg
```c
typedef struct DisasContext {
    DisasContextBase base;
    const ARMISARegisters *isar;

    /* The address of the current instruction being translated. */
    target_ulong pc_curr;
    /*
     * For CF_PCREL, the full value of cpu_pc is not known
     * (although the page offset is known).  For convenience, the
     * translation loop uses the full virtual address that triggered
     * the translation, from base.pc_start through pc_curr.
     * For efficiency, we do not update cpu_pc for every instruction.
     * Instead, pc_save has the value of pc_curr at the time of the
     * last update to cpu_pc, which allows us to compute the addend
     * needed to bring cpu_pc current: pc_curr - pc_save.
     * If cpu_pc now contains the destination of an indirect branch,
     * pc_save contains -1 to indicate that relative updates are no
     * longer possible.
     */
    target_ulong pc_save;
    target_ulong page_start;
    uint32_t insn;
    /* Nonzero if this instruction has been conditionally skipped.  */
    int condjmp;
    /* The label that will be jumped to when the instruction is skipped.  */
    DisasLabel condlabel;
    /* Thumb-2 conditional execution bits.  */
    int condexec_mask;
    int condexec_cond;
    /* M-profile ECI/ICI exception-continuable instruction state */
    int eci;
    /*
     * trans_ functions for insns which are continuable should set this true
     * after decode (ie after any UNDEF checks)
     */
    bool eci_handled;
    int sctlr_b;
    MemOp be_data;
#if !defined(CONFIG_USER_ONLY)
    int user;
#endif
    ARMMMUIdx mmu_idx; /* MMU index to use for normal loads/stores */
    uint8_t tbii;      /* TBI1|TBI0 for insns */
    uint8_t tbid;      /* TBI1|TBI0 for data */
    uint8_t tcma;      /* TCMA1|TCMA0 for MTE */
    bool ns;        /* Use non-secure CPREG bank on access */
    int fp_excp_el; /* FP exception EL or 0 if enabled */
    int sve_excp_el; /* SVE exception EL or 0 if enabled */
    int sme_excp_el; /* SME exception EL or 0 if enabled */
    int vl;          /* current vector length in bytes */
    int svl;         /* current streaming vector length in bytes */
    bool vfp_enabled; /* FP enabled via FPSCR.EN */
    int vec_len;
    int vec_stride;
    bool v7m_handler_mode;
    bool v8m_secure; /* true if v8M and we're in Secure mode */
    bool v8m_stackcheck; /* true if we need to perform v8M stack limit checks */
    bool v8m_fpccr_s_wrong; /* true if v8M FPCCR.S != v8m_secure */
    bool v7m_new_fp_ctxt_needed; /* ASPEN set but no active FP context */
    bool v7m_lspact; /* FPCCR.LSPACT set */
    /* Immediate value in AArch32 SVC insn; must be set if is_jmp == DISAS_SWI
     * so that top level loop can generate correct syndrome information.
     */
    uint32_t svc_imm;
    int current_el;
    GHashTable *cp_regs;
    uint64_t features; /* CPU features bits */
    bool aarch64;
    bool thumb;
    bool lse2;
    /* Because unallocated encodings generate different exception syndrome
     * information from traps due to FP being disabled, we can't do a single
     * "is fp access disabled" check at a high level in the decode tree.
     * To help in catching bugs where the access check was forgotten in some
     * code path, we set this flag when the access check is done, and assert
     * that it is set at the point where we actually touch the FP regs.
     */
    bool fp_access_checked;
    bool sve_access_checked;
    /* ARMv8 single-step state (this is distinct from the QEMU gdbstub
     * single-step support).
     */
    bool ss_active;
    bool pstate_ss;
    /* True if the insn just emitted was a load-exclusive instruction
     * (necessary for syndrome information for single step exceptions),
     * ie A64 LDX*, LDAX*, A32/T32 LDREX*, LDAEX*.
     */
    bool is_ldex;
    /* True if AccType_UNPRIV should be used for LDTR et al */
    bool unpriv;
    /* True if v8.3-PAuth is active.  */
    bool pauth_active;
    /* True if v8.5-MTE access to tags is enabled; index with is_unpriv.  */
    bool ata[2];
    /* True if v8.5-MTE tag checks affect the PE; index with is_unpriv.  */
    bool mte_active[2];
    /* True with v8.5-BTI and SCTLR_ELx.BT* set.  */
    bool bt;
    /* True if any CP15 access is trapped by HSTR_EL2 */
    bool hstr_active;
    /* True if memory operations require alignment */
    bool align_mem;
    /* True if PSTATE.IL is set */
    bool pstate_il;
    /* True if PSTATE.SM is set. */
    bool pstate_sm;
    /* True if PSTATE.ZA is set. */
    bool pstate_za;
    /* True if non-streaming insns should raise an SME Streaming exception. */
    bool sme_trap_nonstreaming;
    /* True if the current instruction is non-streaming. */
    bool is_nonstreaming;
    /* True if MVE insns are definitely not predicated by VPR or LTPSIZE */
    bool mve_no_pred;
    /* True if fine-grained traps are active */
    bool fgt_active;
    /* True if fine-grained trap on SVC is enabled */
    bool fgt_svc;
    /* True if a trap on ERET is enabled (FGT or NV) */
    bool trap_eret;
    /* True if FEAT_LSE2 SCTLR_ELx.nAA is set */
    bool naa;
    /* True if FEAT_NV HCR_EL2.NV is enabled */
    bool nv;
    /* True if NV enabled and HCR_EL2.NV1 is set */
    bool nv1;
    /* True if NV enabled and HCR_EL2.NV2 is set */
    bool nv2;
    /* True if NV2 enabled and NV2 RAM accesses use EL2&0 translation regime */
    bool nv2_mem_e20;
    /* True if NV2 enabled and NV2 RAM accesses are big-endian */
    bool nv2_mem_be;
    /*
     * >= 0, a copy of PSTATE.BTYPE, which will be 0 without v8.5-BTI.
     *  < 0, set by the current instruction.
     */
    int8_t btype;
    /* A copy of cpu->dcz_blocksize. */
    uint8_t dcz_blocksize;
    /* A copy of cpu->gm_blocksize. */
    uint8_t gm_blocksize;
    /* True if this page is guarded.  */
    bool guarded_page;
    /* True if the current insn_start has been updated. */
    bool insn_start_updated;
    /* Bottom two bits of XScale c15_cpar coprocessor access control reg */
    int c15_cpar;
    /* Offset from VNCR_EL2 when FEAT_NV2 redirects this reg to memory */
    uint32_t nv2_redirect_offset;
} DisasContext;
```
- DisaContextBase
```c
/**
 * DisasContextBase:
 * @tb: Translation block for this disassembly.
 * @pc_first: Address of first guest instruction in this TB.
 * @pc_next: Address of next guest instruction in this TB (current during
 *           disassembly).
 * @is_jmp: What instruction to disassemble next.
 * @num_insns: Number of translated instructions (including current).
 * @max_insns: Maximum number of instructions to be translated in this TB.
 * @singlestep_enabled: "Hardware" single stepping enabled.
 * @saved_can_do_io: Known value of cpu->neg.can_do_io, or -1 for unknown.
 * @plugin_enabled: TCG plugin enabled in this TB.
 * @insn_start: The last op emitted by the insn_start hook,
 *              which is expected to be INDEX_op_insn_start.
 *
 * Architecture-agnostic disassembly context.
 */
typedef struct DisasContextBase {
    TranslationBlock *tb;
    vaddr pc_first;
    vaddr pc_next;
    DisasJumpType is_jmp;
    int num_insns;
    int max_insns;
    bool singlestep_enabled;
    bool plugin_enabled;
    struct TCGOp *insn_start;
    void *host_addr[2];
} DisasContextBase;

```
- When encounter a conditional execution, generate a condtional jump to next instruction
```c
    if (cond != 0xe) {
        /* if not always execute, we generate a conditional jump to
           next instruction */
        #if 1
        unsigned int prev_insn = arm_ldl_code(s->env, s->pc - 8, s->sctlr_b);
        if (s->prev_cond == 0xe || s->prev_cond != cond
            || insn_define_cc(prev_insn)
            #ifdef DEBUG_CC
            || is_track_pc(s->tb->pc)
            #endif
            )
        #endif
        {
            s->condlabel = gen_new_label();
            s->condlabel2 = gen_new_label();
            gen_eflag_label(s->condlabel, s->condlabel2, cond);
            arm_gen_test_cc(cond ^ 1, s->condlabel);
            gen_set_label(s->condlabel2);
        }
        //else
        //    fprintf(stderr, "    0x%x,\n", s->tb->pc);
        s->condjmp = 1;
    }
    s->prev_cond = cond;
```
## TCGTemp

```c
typedef struct TCGTemp {
    TCGReg reg:8;
    TCGTempVal val_type:8;
    TCGType base_type:8;
    TCGType type:8;
    unsigned int fixed_reg:1;
    unsigned int indirect_reg:1;
    unsigned int indirect_base:1;
    unsigned int mem_coherent:1;
    unsigned int mem_allocated:1;
    unsigned int temp_local:1; /* If true, the temp is saved across
                                  basic blocks. Otherwise, it is not
                                  preserved across basic blocks. */
    unsigned int temp_allocated:1; /* never used for code gen */

    tcg_target_long val;
    struct TCGTemp *mem_base;
    intptr_t mem_offset;
    const char *name;
} TCGTemp;

```

## TCGOpCode
```c
/* predefined ops */
DEF(discard, 1, 0, 0, TCG_OPF_NOT_PRESENT)
DEF(set_label, 0, 0, 1, TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT)
DEF(ld8u_i32, 1, 1, 1, 0)

typedef enum TCGOpcode {
#define DEF(name, oargs, iargs, cargs, flags) INDEX_op_ ## name,
#include "tcg/tcg-opc.h"
#undef DEF
    NB_OPS,
} TCGOpcode;
```

- Parameters
  - name: Opcode name (e.g., discard, set_label, ld8u_i32)
  - oargs: Number of output arguments
  - iargs: Number of input arguments
  - cargs: Number of compile-time constant arguments
  - flags: Behavioral flags (e.g., TCG_OPF_BB_END)

- The preprocessor:
  - Redefines DEF to generate INDEX_op_<name> entries
  - Includes tcg-opc.h (which contains all DEF invocations)
  - Undefines DEF afterward

Resulting expansion example:
```c
typedef enum TCGOpcode {
    INDEX_op_discard,
    INDEX_op_set_label, 
    INDEX_op_ld8u_i32,
    /* ... */
    NB_OPS,  // Counts total number of ops
} TCGOpcode;
```

