---
title: Learning Build frameworks from QEMU  
date: 2025-04-09
categories: [Project Management]
tags: [proj_man]     # TAG names should always be lowercase
---

> I want to add some files and sub-directories into an existed QEMU, but I am not familiar with MESON, Ninja and how they interact with Makefiles

# How QEMU's meson build works
> Resources can be found here [references](https://www.qemu.org/docs/master/devel/build-system.html)

## Stage 1: configure
Prepares the environment for building the project by checking for dependencies, setting configuration options, and generating necessary files. Below is a detailed breakdown of how the configure process typically works, divided into sections and stages.
It has five tasks:
- detect the host architecture
- list the targets for which to build emulators; the list of targets also affects which firmware binaries and tests to build
- find the compilers (native and cross) used to build executables, firmware and tests. The results are written as either Makefile fragments `(config-host.mak`) or a Meson machine file (`config-meson.cross`)
- create a virtual environment in which all Python code runs during the build, and possibly install packages into it from PyPI
- invoke Meson in the virtual environment, to perform the actual configuration step for the emulator build

The configure script automatically recognizes command line options for which a same-named Meson option exists; dashes in the command line are replaced with underscores.
Almost all QEMU developers that need to modify the build system will only be concerned with Meson, and therefore can skip the rest of this section.
### concrete examples
1. Option Parsing
In the provided snippet, the script begins by parsing command-line options:
```shell
for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --cross-prefix=*) cross_prefix="$optarg"
                    cross_compile="yes"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --cxx=*) CXX="$optarg"
  ;;
  --objcc=*) objcc="$optarg"
  ;;
  --cpu=*) cpu="$optarg"
  ;;
```
2. Depedency Checks
- Determine which optional features can be enabled based on the available libraries and tools.
3. Generating Configuration Files
After parsing the options, the script generates configuration files based on the provided options and checks for dependencies. For example, it creates `config-target.mak` file from `config_host_mak` for each target architecture.
```shell
#######################################
# generate config-host.mak
config_host_mak="config-host.mak"

echo "# Automatically generated by configure - do not modify" > $config_host_mak
echo >> $config_host_mak

echo all: >> $config_host_mak

echo "SRC_PATH=$source_path" >> $config_host_mak
echo "TARGET_DIRS=$target_list" >> $config_host_mak
echo "GDB=$gdb_bin" >> $config_host_mak
if test "$container" != no; then
    echo "RUNC=$runc" >> $config_host_mak
fi
echo "SUBDIRS=$subdirs" >> $config_host_mak
echo "PYTHON=$python" >> $config_host_mak
echo "MKVENV_ENSUREGROUP=$mkvenv ensuregroup $mkvenv_online_flag" >> $config_host_mak
echo "GENISOIMAGE=$genisoimage" >> $config_host_mak
echo "MESON=$meson" >> $config_host_mak
echo "NINJA=$ninja" >> $config_host_mak
echo "EXESUF=$EXESUF" >> $config_host_mak
if test "$default_targets" = "yes"; then
  echo "CONFIG_DEFAULT_TARGETS=y" >> $config_host_mak
fi
# then generate test config_host_mak for each target arch
tcg_tests_targets=
for target in $target_list; do
  arch=${target%%-*}

  case $target in
    xtensa*-linux-user)
      # the toolchain is not complete with headers, only build system tests
      continue
      ;;
    *-softmmu)
      test -f "$source_path/tests/tcg/$arch/Makefile.softmmu-target" || continue
      qemu="qemu-system-$arch"
      ;;
    *-linux-user|*-bsd-user)
      qemu="qemu-$arch"
      ;;
  esac

  if probe_target_compiler $target || test -n "$container_image"; then
      test -n "$container_image" && build_static=y
      mkdir -p "tests/tcg/$target"
      config_target_mak=tests/tcg/$target/config-target.mak
      ln -sf "$source_path/tests/tcg/Makefile.target" "tests/tcg/$target/Makefile"
      echo "# Automatically generated by configure - do not modify" > "$config_target_mak"
      echo "TARGET_NAME=$arch" >> "$config_target_mak"
      echo "TARGET=$target" >> "$config_target_mak"
      write_target_makefile "build-tcg-tests-$target" >> "$config_target_mak"
      echo "BUILD_STATIC=$build_static" >> "$config_target_mak"
      echo "QEMU=$PWD/$qemu" >> "$config_target_mak"

      # will GDB work with these binaries?
      if test "${gdb_arches#*$arch}" != "$gdb_arches"; then
          echo "GDB=$gdb_bin" >> $config_target_mak
      fi

      echo "run-tcg-tests-$target: $qemu\$(EXESUF)" >> Makefile.prereqs
      tcg_tests_targets="$tcg_tests_targets $target"
  fi
done
```
4. Calling Meson and Ninja
After setting up the configuration, the script calls Meson to set up the build environment and then uses Ninja to build the project, like `meson_options="$meson_options $opt"`
```shell
if test "$skip_meson" = no; then
  # ... (configuration code) ...
  echo "[built-in options]" >> $cross
  echo "c_args = [$(meson_quote $CFLAGS $EXTRA_CFLAGS)]" >> $cross
  echo "cpp_args = [$(meson_quote $CXXFLAGS $EXTRA_CXXFLAGS)]" >> $cross
  test -n "$objcc" && echo "objc_args = [$(meson_quote $OBJCFLAGS $EXTRA_OBJCFLAGS)]" >> $cross
  echo "c_link_args = [$(meson_quote $CFLAGS $LDFLAGS $EXTRA_CFLAGS $EXTRA_LDFLAGS)]" >> $cross
  echo "cpp_link_args = [$(meson_quote $CXXFLAGS $LDFLAGS $EXTRA_CXXFLAGS $EXTRA_LDFLAGS)]" >> $cross
  # ... (configuration code) ...
  run_meson() {
    NINJA=$ninja $meson setup "$@" "$PWD" "$source_path"
  }
  eval run_meson $meson_options
  if test "$?" -ne 0 ; then
      error_exit "meson setup failed"
  fi
  echo "$meson" > build.ninja.stamp
```


## Stage 2: Meson
The Meson build system describes the build and install process for:
- executables, which include:
    - Tools - qemu-img, qemu-nbd, qemu-ga (guest agent), etc
    - System emulators - qemu-system-$ARCH
    - Userspace emulators - qemu-$ARCH
    - Unit tests
- documentation
- ROMs, whether provided as binary blobs in the QEMU distributions or cross compiled under the direction of the configure script
- other data files, such as icons or desktop files

All executables are built by default, except for some contrib/ binaries that are known to fail to build on some platforms (for example 32-bit or big-endian platforms). Tests are also built by default, though that might change in the future.

The source code is highly modularized, split across many files to facilitate building of all of these components with as little duplicated compilation as possible. Using the Meson “sourceset” functionality, meson.build files group the source files in rules that are enabled according to the available system libraries and to various configuration symbols. Sourcesets belong to one of four groups:

- Subsystem sourcesets:
Tools and emulators have their own various subsystems sourceset, for example `block_ss` for the block device subsystem, `chardev_ss` for the character device subsystem, etc. These sourcesets are then turned into static libraries as follows:
```shell
libchardev = static_library('chardev', chardev_ss.sources(),
                            build_by_default: false)

chardev = declare_dependency(objects: libchardev.extract_all_objects(recursive: false),
                             dependencies: chardev_ss.dependencies())
```
- Target-independent emulator sourcesets:
target: who are ended with '-user', like `linux-user`
Various general purpose helper code is compiled only once and the .o files are linked into all output binaries that need it. This includes error handling infrastructure, standard data structures, platform portability wrapper functions, etc.
Target-independent code lives in the common_ss, system_ss and user_ss sourcesets. common_ss is linked into all emulators, system_ss only in system emulators, user_ss only in user-mode emulators.
- Target-dependent emulator sourcesets:
Host configures are from `config_host = keyval.load(meson.current_build_dir() / 'config-host.mak')`
In the target-dependent set lives CPU emulation, some device emulation and much glue code. This sometimes also has to be compiled multiple times, once for each target being built. Target-dependent files are included in the specific_ss sourceset.

Each emulator also includes sources for files in the hw/ and target/ subdirectories. The subdirectory used for each emulator comes from the target’s definition of TARGET_BASE_ARCH or (if missing) TARGET_ARCH, as found in `configs/targets/*.mak.`
Each subdirectory in hw/ adds one sourceset to the hw_arch dictionary, for example:
```shell
# accel modules
qtest_module_ss = ss.source_set()
tcg_module_ss = ss.source_set()
modules = {} # is used for target-independent modules 
target_modules = {} #  is used for target-dependent modules
hw_arch = {}
target_arch = {}
target_system_arch = {}
target_user_arch = {}
...
if enable_modules
  foreach target : target_dirs
    if target.endswith('-softmmu')
      config_target = config_target_mak[target]
      config_devices_mak = target + '-config-devices.mak'
      modinfo_src = custom_target('modinfo-' + target + '.c',
                                  output: 'modinfo-' + target + '.c',
                                  input: modinfo_files,
                                  command: [modinfo_generate, '--devices', config_devices_mak, '@INPUT@'],
                                  capture: true)

      modinfo_lib = static_library('modinfo-' + target + '.c', modinfo_src)
      modinfo_dep = declare_dependency(link_with: modinfo_lib)

      arch = config_target['TARGET_NAME'] == 'sparc64' ? 'sparc64' : config_target['TARGET_BASE_ARCH']
      hw_arch[arch].add(modinfo_dep)
    endif
  endforeach
endif
```
The sourceset is only used for system emulators.
Each subdirectory in `target/` instead should add one sourceset to each of the target_arch and target_system_arch, which are used respectively for all emulators and for system emulators only. 

- Module sourcesets:
Both dictionaries are nested. One dictionary is created per subdirectory, and these per-subdirectory dictionaries are added to the toplevel dictionaries. For example:
```shell
hw_display_modules = {}
qxl_ss = ss.source_set()
...
hw_display_modules += { 'qxl': qxl_ss }
modules += { 'hw-display': hw_display_modules }
```
### Pipelines: Overview of Meson Build Process
- 0. After configuration: 
  - The user runs the meson setup command, specifying the build directory and source directory. This command initializes the build environment.
  - Dependency Checks: Meson checks for required dependencies, libraries, and tools specified in the meson.build files.
  - Generate Build Files: Meson generates a build.ninja file, which contains the instructions for the Ninja build system.
- 1. Project Definition: `project('qemu', meson_verison:'>=0.63')`
```shell
project('qemu', ['c'], meson_version: '>=0.63.0',
        default_options: ['warning_level=1', 'c_std=gnu11', 'cpp_std=gnu++11', 'b_colorout=auto',
                          'b_staticpic=false', 'stdsplit=false', 'optimization=2', 'b_pie=true'],
        version: files('VERSION'))

add_test_setup('quick', exclude_suites: ['slow', 'thorough'], is_default: true)
add_test_setup('slow', exclude_suites: ['thorough'], env: ['G_TEST_SLOW=1', 'SPEED=slow'])
add_test_setup('thorough', env: ['G_TEST_SLOW=1', 'SPEED=thorough'])
```
- 2. Test Setup Stage: configures different test environments
```shell
add_test_setup('quick', exclude_suites: ['slow', 'thorough'], is_default: true)
add_test_setup('slow', exclude_suites: ['thorough'], env: ['G_TEST_SLOW=1', 'SPEED=slow'])
add_test_setup('thorough', env: ['G_TEST_SLOW=1', 'SPEED=thorough'])
```
- 3. Global Variables and Dependencies Stage: This stage initializes global variables and checks for dependencies. Various modules are imported, and dependencies are defined. This allows for managing source files and configurations effectively
```shell
not_found = dependency('', required: false)
keyval = import('keyval')
ss = import('sourceset')
fs = import('fs')
```
- 4. Host and Target Configuration Stage: This stage determines the host architecture and sets up configurations based on the target. This stage determines the host architecture and sets up configurations based on the target.
```shell
host_os = host_machine.system()
config_host = keyval.load(meson.current_build_dir() / 'config-host.mak')
```
- 5. Source File Management Stage
Source sets are created for different modules (e.g., authz, blockdev). Each source set will contain the relevant C files for that module.
```shell
authz_ss = ss.source_set()
blockdev_ss = ss.source_set()
```
- 6. Subdirectory Inclusion Stage: The subdir() function is used to include other directories, allowing for modular organization of the codebase. Each subdirectory can have its own `meson.build` file that defines its specific build rules.
```shell
subdir('qapi')
subdir('qobject')
subdir('stubs')
subdir('trace')
subdir('util')
subdir('qom')
subdir('authz')
subdir('crypto')
subdir('ui')
subdir('hw')
subdir('gdbstub')
```
- 7. Target Construction Stage: The `static_library()` function creates static libraries from the source sets, merging all the relevant C files into a single library. This stage constructs the final targets (executables, libraries) from the collected source sets.
## Stage 3: Make
The output of Meson is a build.ninja file, which is used with the Ninja build tool. 
The QEMU Makefile wraps both Ninja and the smaller build systems for firmware and tests; it also takes care of running configure again when the script changes. Apart from invoking these sub-Makefiles, the resulting build is largely non-recursive.
Tests, whether defined in meson.build or not, are also ran by the Makefile with the traditional make check phony target, while benchmarks are run with make bench. Meson test suites such as unit can be ran with make check-unit, and make check-tcg builds and runs “non-Meson” tests for all targets.
### Examples
1. Run the Configure Script: The user runs the configure script, which detects the build environment and generates necessary configuration files, including config-host.mak and config-meson.cross.
2. Invoke Meson: The configure script invokes Meson to generate the build.ninja file, which contains the build instructions.
3. Build with Ninja: The Makefile uses Ninja to compile the source files and link them into the final QEMU binary.
4. Run Tests: The Makefile can also trigger tests defined in the Meson build files.
5. Clean Up: The Makefile provides a clean target to remove build artifacts.
```shell
# 1. ensure config-host.mak is up-to-date
config-host.mak: $(SRC_PATH)/configure $(SRC_PATH)/scripts/meson-buildoptions.sh $(SRC_PATH)/VERSION
	@echo config-host.mak is out-of-date, running configure
	@if test -f meson-private/coredata.dat; then \
	  ./config.status --skip-meson; \
	else \
	  ./config.status; \
	fi
# 2. meson.stamp exists if meson has run at least once (so ninja reconfigure
# works), but otherwise never needs to be updated
meson-private/coredata.dat: meson.stamp
meson.stamp: config-host.mak
	@touch meson.stamp
# 3. ensure meson-generated build files are up-to-date
ifneq ($(NINJA),)
Makefile.ninja: build.ninja
	$(quiet-@){ \
	  echo 'ninja-targets = \'; \
	  $(NINJA) -t targets all | sed 's/:.*//; $$!s/$$/ \\/'; \
	  echo 'build-files = \'; \
	  $(NINJA) -t query build.ninja | sed -n '1,/^  input:/d; /^  outputs:/q; s/$$/ \\/p'; \
	} > $@.tmp && mv $@.tmp $@
-include Makefile.ninja
endif
```

# MESON
- [Meson Introduction](https://mesonbuild.com/Quick-guide.html)
- `meson.build`: setup by `meson setup builddir`
- Setting compiler and linker version: Like the compiler, the linker is selected via the `<compiler variable>_LD` environment variable, or through the `<compiler entry>_ld` entry in a native or cross file. You must be aware of whether you're using a compiler that invokes the linker itself (most compilers including GCC and Clang) or a linker that is invoked directly (when using MSVC or compilers that act like it, including Clang-Cl). With the former `c_ld` or `CC_LD` should be the value to pass to the compiler's special argument (such as `-fuse-ld` with `clang` and `gcc`), with the latter it should be an executable, such as `lld-link.exe`.
```shell
CC=clang CC_LD=lld meson <options>
```
- Set default C/C++ language version
```shell
project('myproj', 'c', 'cpp',
        default_options : ['c_std=c11', 'cpp_std=c++11'])
# The language version can also be set on a per-target basis.
executable(..., override_options : ['c_std=c11'])
```
-Set extra compiler and linker flags from the outside (when e.g. building distro packages): The behavior is the same as with other build systems, with environment variables during first invocation. Do not use these when you need to rebuild the source
```shell
$ CFLAGS=-fsomething LDFLAGS=-Wl,--linker-flag meson <options>
```
- Enable threads
```shell
thread_dep = dependency('threads')
executable(..., dependencies : thread_dep)
```
- Use an argument only with a specific compiler
```shell
if meson.get_compiler('c').get_id() == 'clang'
  extra_args = ['-fclang-flag']
else
  extra_args = []
endif
# Then use it in a target.
executable(..., c_args : extra_args)
# If you want to use the arguments on all targets, then do this.
if meson.get_compiler('c').get_id() == 'clang'
  add_global_arguments('-fclang-flag', language : 'c')
endif
```
- example to collect information about coimpiler settings
```shell
# example to collect information about coimpiler settings
summary_info += {'C compiler':        ' '.join(meson.get_compiler('c').cmd_array())}
summary_info += {'Host C compiler':   ' '.join(meson.get_compiler('c', native: true).cmd_array())}
if 'cpp' in all_languages
  summary_info += {'C++ compiler':    ' '.join(meson.get_compiler('cpp').cmd_array())}
else
  summary_info += {'C++ compiler':      false}
endif
```
- `source_set()`: collect source files and dependencies

| Usage | Meaning |
| --- | --- |
| `ss.source_set()` | Create a new mutable source set |
| `.add(files(...))` | Add files to the source set |
| `.apply({})` | Finalize the source set for use |
| `.sources()` | Get list of source files |
| `.dependencies()` | Get list of dependencies |

# Debug in meson
- use its own function `mesesage`
```shell
# Debug Meson message('Debug meson have_user: @0@'.format(have_user)) true
message('Debug meson have_linux_user: @0@'.format(have_linux_user)) # true
message('Debug meson have_bsd_user: @0@'.format(have_bsd_user)) # false
message('Target dirs: @0@'.format(target_dirs)) # arm-linux-user
```
- use custom build function
```shell
config_host = keyval.load(meson.current_build_dir() / 'config-host.mak')
# Convert dict to string (basic format)
config_string = ''
foreach k, v : config_host
  config_string += '@0@=@1@\n'.format(k, v)
endforeach
# Dump using a script
dump_script = files('dump_config_host.py')
run_command(find_program('python3'), dump_script, config_string, 'config_output.txt', check: true)
# Python file dump_config_host.py
import sys
import json
config = sys.argv[1]
output = sys.argv[2]
with open(output, 'w') as f:
    f.write(config)
```
- for configuration data, it can be saved by `configure_file`
```shell
config_host_data = configuration_data() # a data type like a key-value pairs
...
config_host_data.set('CONFIG_FDT', fdt.found())
...
configure_file(output: 'config-host.h', configuration: config_host_data)
```
```h
// config-host.h
/*
 * Autogenerated by the Meson build system.
 * Do not edit, your changes will be lost.
 */

#pragma once

#define CONFIG_ACCEPT4

#undef CONFIG_AF_ALG

#define CONFIG_AF_VSOCK

#undef CONFIG_AF_XDP

#undef CONFIG_ALIGNED_MALLOC

#undef CONFIG_ARM_AES_BUILTIN

#define CONFIG_ASAN_IFACE_FIBER

#undef CONFIG_ATOMIC128

#undef CONFIG_ATOMIC128_OPT

#define CONFIG_ATOMIC64

#define CONFIG_ATTR

#define CONFIG_AUDIO_DRIVERS "", 

#define CONFIG_AVX2_OPT

#define CONFIG_AVX512BW_OPT

#undef CONFIG_AVX512F_OPT

#define CONFIG_BDRV_RO_WHITELIST 

#define CONFIG_BDRV_RW_WHITELIST 

#undef CONFIG_BDRV_WHITELIST_TOOLS

#define CONFIG_BINDIR "/usr/local/bin"
```
- There are `config-host.h`, `arm-linux-user-config-target.h`, `config-poison.h`, 
## some settings in QEMU
Host-specific configuration of accelerators
```
accelerators = ['CONFIG_KVM', 'CONFIG_TCG']
```

## The process to build target

```shell
foreach target : target_dirs
  config_target = config_target_mak[target]
  target_name = config_target['TARGET_NAME']
  target_base_arch = config_target['TARGET_BASE_ARCH']
  arch_srcs = [config_target_h[target]]
  arch_deps = []
  c_args = ['-DNEED_CPU_H',
            '-DCONFIG_TARGET="@0@-config-target.h"'.format(target),
            '-DCONFIG_DEVICES="@0@-config-devices.h"'.format(target)]
  link_args = emulator_link_args

  target_inc = [include_directories('target' / config_target['TARGET_BASE_ARCH'])] # add translate.c/translate.h into the whole tcg build process 
  if host_os == 'linux'
    target_inc += include_directories('linux-headers', is_system: true)
  endif
  if target.endswith('-softmmu')
    target_type='system'
    t = target_system_arch[target_base_arch].apply(config_target, strict: false)
    arch_srcs += t.sources()
    arch_deps += t.dependencies()

    hw_dir = target_name == 'sparc64' ? 'sparc64' : target_base_arch
    if hw_arch.has_key(hw_dir)
      hw = hw_arch[hw_dir].apply(config_target, strict: false)
      arch_srcs += hw.sources()
      arch_deps += hw.dependencies()
    endif

    arch_srcs += config_devices_h[target]
    link_args += ['@block.syms', '@qemu.syms']
  else
    abi = config_target['TARGET_ABI_DIR']
    target_type='user'
    target_inc += common_user_inc
    if target_base_arch in target_user_arch
      t = target_user_arch[target_base_arch].apply(config_target, strict: false)
      arch_srcs += t.sources()
      arch_deps += t.dependencies()
    endif
    if 'CONFIG_LINUX_USER' in config_target
      base_dir = 'linux-user'
    endif
    if 'CONFIG_BSD_USER' in config_target
      base_dir = 'bsd-user'
      target_inc += include_directories('bsd-user/' / host_os)
      target_inc += include_directories('bsd-user/host/' / host_arch)
      dir = base_dir / abi
      arch_srcs += files(dir / 'signal.c', dir / 'target_arch_cpu.c')
    endif
    target_inc += include_directories(
      base_dir,
      base_dir / abi,
    )
    if 'CONFIG_LINUX_USER' in config_target
      dir = base_dir / abi
      arch_srcs += files(dir / 'signal.c', dir / 'cpu_loop.c')
      if config_target.has_key('TARGET_SYSTBL_ABI')
        arch_srcs += \
          syscall_nr_generators[abi].process(base_dir / abi / config_target['TARGET_SYSTBL'],
                                             extra_args : config_target['TARGET_SYSTBL_ABI'])
      endif
    endif
  endif
```

- for target arm in `target/arm`, specially added into `target_arch`, `target_user_arch`, `target_system_arch`
```shell
arm_ss = ss.source_set()
arm_ss.add(files(
  'cpu.c',
  'debug_helper.c',
  'gdbstub.c',
  'helper.c',
  'vfp_helper.c',
))
arm_ss.add(zlib)

arm_ss.add(when: 'CONFIG_KVM', if_true: files('hyp_gdbstub.c', 'kvm.c'), if_false: files('kvm-stub.c'))
arm_ss.add(when: 'CONFIG_HVF', if_true: files('hyp_gdbstub.c'))

arm_ss.add(when: 'TARGET_AARCH64', if_true: files(
  'cpu64.c',
  'gdbstub64.c',
))

arm_system_ss = ss.source_set()
arm_system_ss.add(files(
  'arch_dump.c',
  'arm-powerctl.c',
  'arm-qmp-cmds.c',
  'cortex-regs.c',
  'machine.c',
  'ptw.c',
))

arm_user_ss = ss.source_set()

subdir('hvf')

if 'CONFIG_TCG' in config_all_accel
   subdir('tcg')
else
    arm_ss.add(files('tcg-stubs.c'))
endif

target_arch += {'arm': arm_ss}
target_system_arch += {'arm': arm_system_ss}
target_user_arch += {'arm': arm_user_ss}
```
- and used here
```shell
# Place 1
  if target_base_arch in target_user_arch
    t = target_user_arch[target_base_arch].apply(config_target, strict: false)
    arch_srcs += t.sources()
    arch_deps += t.dependencies()
  endif
# Place 2
  t = target_arch[target_base_arch].apply(config_target, strict: false)
```

## Global arguments
Prefer add_project_arguments to add_global_arguments because using the latter prevents using the project as a subproject.
```shell
add_project_arguments('-iquote', meson.current_source_dir() / 'tcg' / tcg_arch,
                      language: all_languages)
```

### check into the tcg resources
tcg part:
- 1. common: 
  - tcg
  - tcg-target.h contains the common target definitions. `tcg-target.c.inc` defines in `tcg.c`
contains the host code which is linked to backend, so that QEMU can emit host code for op; it is #included by tcg/tcg.c, rather than being a standalone C file.
- 2. specific:
  - accel/tcg --> built in specific_ss ==> target_specific
  - target/tcg --> target_arch[target_base_arch].apply(config_target, strict: false)

### what are in the speicific_ss -> add in to arch_srcs
- target-dependent files
  - cpu-target.c
  - accel/accel-target.c, 
    - accel/tcgtranslate-all.c
  - hw/[arch]
  - target/target-common.h -> "cpu.h"
  - ...
### what are in the arch_srcs
- target headers 
  - target + '-config-target.h'
  - if softmmu enabled: target + '-config-devices.h'
- if softmmu enable: system settings
- Special sources for one arch: target_arch[target_base_arch] --> cpu.h, target/[arch]/tcg/** *
- Other settings if more options enabled user, system, bsd

### An interesting find
For `tcg/tcg.c`, it includes `tcg-target.c.inc`, I thought it is for target-specific code, however, after investigation, I found it is used to define the host code, and meson project add the host machine arch to the global, to show where to find the c.inc file
- Gotten from build/tcg/libtcg_user.fa.p/tcg.c.o.d
```c
 /workspace/tcg/i386/tcg-target.c.inc \
 /workspace/tcg/i386/../tcg-ldst.c.inc \
``` 

## To Avoid being poisoned
- Specific code for host arch should be put into `tcg/arm/tcg-target.h`, which is contained in the `tcg/tcg.h`
- During compilation, use conditonal add to align with the architecture-specific behaviors rather than adding into common lib/sources.